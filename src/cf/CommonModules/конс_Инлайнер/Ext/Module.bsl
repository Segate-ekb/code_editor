////////////////////////////////////////////////////////////////////////////////
// конс_Инлайнер — преобразует код модуля с процедурами/функциями
// в плоский код, пригодный для выполнения через оператор Выполнить().
//
// Поддерживает:
//   - Процедуры и функции с параметрами (Знач, значения по умолчанию)
//   - Вызовы процедур как отдельных операторов
//   - Вызовы функций в присваиваниях и выражениях
//   - Множественные Возврат (через флаг завершения)
//   - Вложенные вызовы: Foo(Bar(1))
//   - Обнаружение рекурсии (ограничение глубины)
//   - Русские и английские ключевые слова BSL
//   - Маркеры //@@N для реверс-маппинга строк
//
// Ограничения:
//   - Не поддерживается взаимная рекурсия
//   - Директивы компиляции (&НаСервере и т.д.) игнорируются
//   - Препроцессорные инструкции (#Если и т.д.) не обрабатываются внутри тел методов
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Основная точка входа — инлайнит код.
//
// Параметры:
//   Код - Строка - исходный BSL-код с процедурами/функциями
//
// Возвращаемое значение:
//   Строка - плоский код без определений процедур/функций, с маркерами //@@N
//
Функция Инлайн(Знач Код) Экспорт
	
	Контекст = НовыйКонтекст(Код);
	Возврат Обработать(Контекст);
	
КонецФункции

// Извлекает номер оригинальной строки из маркера //@@N в строке кода.
//
// Параметры:
//   СтрокаКода - Строка - строка кода с маркером (например: "Р = Р * Квапв //@@24")
//
// Возвращаемое значение:
//   Число - номер строки из маркера, или 0 если маркер не найден
//
Функция ИзвлечьНомерСтрокиИзМаркера(Знач СтрокаКода) Экспорт
	
	Возврат ИзвлечьНомерИзМаркера(СтрокаКода);
	
КонецФункции

// Извлекает номер оригинальной строки из маркера //@@N в тексте кода.
//
// Параметры:
//   ТекстКода - Строка - полный текст кода с маркерами
//   НомерСтроки - Число - номер строки (1-based)
//
// Возвращаемое значение:
//   Число - номер оригинальной строки или НомерСтроки если маркер не найден
//
Функция ПолучитьОригинальнуюСтроку(Знач ТекстКода, Знач НомерСтроки) Экспорт
	
	Если Не ЗначениеЗаполнено(ТекстКода) Тогда
		Возврат НомерСтроки;
	КонецЕсли;
	
	Строки = СтрРазделить(ТекстКода, Символы.ПС);
	Индекс = НомерСтроки - 1;
	
	Если Индекс >= 0 И Индекс < Строки.Количество() Тогда
		Номер = ИзвлечьНомерИзМаркера(Строки[Индекс]);
		Если Номер > 0 Тогда
			Возврат Номер;
		КонецЕсли;
	КонецЕсли;
	
	Возврат НомерСтроки;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область КонтекстИнлайнера

// Создаёт новый контекст инлайнера.
Функция НовыйКонтекст(Знач ИсходныйКод)
	
	Контекст = Новый Структура;
	Контекст.Вставить("ИсходныйКод", ИсходныйКод);
	Контекст.Вставить("Методы", Новый Соответствие);        // ИмяНижнийРегистр → ОписаниеМетода
	Контекст.Вставить("СчётчикИнлайна", 0);
	Контекст.Вставить("МаксГлубина", 20);
	
	Возврат Контекст;
	
КонецФункции

// Создаёт описание метода.
Функция НовоеОписаниеМетода()
	
	Описание = Новый Структура;
	Описание.Вставить("Имя", "");
	Описание.Вставить("Параметры", Новый Массив);            // Массив из ОписаниеПараметра
	Описание.Вставить("Тело", "");
	Описание.Вставить("ЭтоФункция", Ложь);
	Описание.Вставить("КоличествоВозвратов", 0);
	Описание.Вставить("НомерСтрокиНачалаТела", 0);          // 1-based
	
	Возврат Описание;
	
КонецФункции

// Создаёт описание параметра.
Функция НовоеОписаниеПараметра()
	
	Описание = Новый Структура;
	Описание.Вставить("Имя", "");
	Описание.Вставить("ПоЗначению", Ложь);
	Описание.Вставить("ЗначениеПоУмолчанию", Неопределено); // Строка или Неопределено
	
	Возврат Описание;
	
КонецФункции

#КонецОбласти

#Область ОсновнойПроцесс

// Выполняет полный цикл инлайнинга.
Функция Обработать(Контекст)
	
	РазобратьОпределенияМетодов(Контекст);
	
	Если Контекст.Методы.Количество() = 0 Тогда
		// Без методов — просто добавляем маркеры с учётом многострочных выражений
		СтрокиКода = СтрРазделить(Контекст.ИсходныйКод, Символы.ПС);
		ВнутриЛитерала = Ложь;
		БалансСкобок = 0;
		НомерНачалаВыражения = 0;
		Для Инд = 0 По СтрокиКода.ВГраница() Цикл
			Строка = СтрокиКода[Инд];
			НомерТекущейСтроки = Инд + 1;
			
			// Если начинается новое выражение - запоминаем номер строки
			Если Не ВнутриЛитерала И БалансСкобок <= 0 Тогда
				НомерНачалаВыражения = НомерТекущейСтроки;
			КонецЕсли;
			
			// Анализируем строку
			Анализ = АнализСостоянияСтроки(Строка, ВнутриЛитерала, Макс(БалансСкобок, 0));
			ВнутриЛитерала = Анализ.ВнутриЛитерала;
			БалансСкобок = Анализ.БалансСкобок;
			
			Если Анализ.МожноДобавитьМаркер Тогда
				СтрокиКода[Инд] = Строка + " //@@" + Формат(НомерНачалаВыражения, "ЧГ=");
			КонецЕсли;
		КонецЦикла;
		Возврат СтрСоединить(СтрокиКода, Символы.ПС);
	КонецЕсли;
	
	ОсновноеТело = ИзвлечьОсновноеТело(Контекст);
	КодТела = ОсновноеТело.Код;
	КартаСтрок = ОсновноеТело.КартаСтрок;
	
	Результат = ИнлайнитьВызовыСКартой(Контекст, КодТела, КартаСтрок, 0);
	
	// Добавляем маркеры //@@N только к строкам без маркеров
	// Учитываем многострочные выражения (литералы, скобки)
	СтрокиВыхода = СтрРазделить(Результат.Код, Символы.ПС);
	ВнутриЛитерала = Ложь;
	БалансСкобок = 0;
	НомерНачалаВыражения = 0;
	Для Инд = 0 По СтрокиВыхода.ВГраница() Цикл
		Строка = СтрокиВыхода[Инд];
		
		// Получаем оригинальный номер строки из карты
		ОригНомер = 0;
		Если Инд < Результат.Карта.Количество() Тогда
			ОригНомер = Результат.Карта[Инд];
		КонецЕсли;
		
		// Если начинается новое выражение - запоминаем номер строки
		Если Не ВнутриЛитерала И БалансСкобок <= 0 Тогда
			НомерНачалаВыражения = ОригНомер;
		КонецЕсли;
		
		// Если уже есть маркер - пропускаем, но отслеживаем состояние строки
		Если ЕстьМаркер(Строка) Тогда
			СтрокаБезМаркера = ИзвлечьМаркер(Строка).ТекстБезМаркера;
			Анализ = АнализСостоянияСтроки(СтрокаБезМаркера, ВнутриЛитерала, Макс(БалансСкобок, 0));
			ВнутриЛитерала = Анализ.ВнутриЛитерала;
			БалансСкобок = Анализ.БалансСкобок;
			Продолжить;
		КонецЕсли;
		
		// Строки-продолжения многострочных литералов (|...)
		Если ЭтоПродолжениеМногострочнойСтроки(Строка) Тогда
			Анализ = АнализСостоянияСтроки(Строка, ВнутриЛитерала, Макс(БалансСкобок, 0));
			ВнутриЛитерала = Анализ.ВнутриЛитерала;
			БалансСкобок = Анализ.БалансСкобок;
			// Маркер добавляем только если выражение завершилось на этой строке
			Если Анализ.МожноДобавитьМаркер Тогда
				СтрокиВыхода[Инд] = Строка + " //@@" + Формат(НомерНачалаВыражения, "ЧГ=");
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		
		// Анализируем строку
		Анализ = АнализСостоянияСтроки(Строка, ВнутриЛитерала, Макс(БалансСкобок, 0));
		ВнутриЛитерала = Анализ.ВнутриЛитерала;
		БалансСкобок = Анализ.БалансСкобок;
		
		Если Анализ.МожноДобавитьМаркер Тогда
			СтрокиВыхода[Инд] = Строка + " //@@" + Формат(НомерНачалаВыражения, "ЧГ=");
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрСоединить(СтрокиВыхода, Символы.ПС);
	
КонецФункции

#КонецОбласти

#Область ПарсингМетодов

// Парсит все определения Процедура/Функция из исходного кода.
Процедура РазобратьОпределенияМетодов(Контекст)
	
	Строки = СтрРазделить(Контекст.ИсходныйКод, Символы.ПС);
	ТекущийМетод = Неопределено;
	СтрокиТела = Новый Массив;
	ГлубинаВложенности = 0;
	СобираемСигнатуру = Ложь;
	СтрокиСигнатуры = Новый Массив;
	ИндексНачалаСигнатуры = 0;
	
	Для Инд = 0 По Строки.ВГраница() Цикл
		Строка = Строки[Инд];
		Обрезанная = СокрЛП(Строка);
		
		Если ТекущийМетод = Неопределено Тогда
			// Вне метода
			Если СтрНачинаетсяС(Обрезанная, "&") Тогда
				Продолжить; // Директива компиляции
			КонецЕсли;
			
			Если СобираемСигнатуру Тогда
				// Продолжаем собирать многострочную сигнатуру
				СтрокиСигнатуры.Добавить(Строка);
				// Объединяем с переводом строки для сохранения многострочных литералов
				ПолнаяСигнатура = СтрСоединить(СтрокиСигнатуры, Символы.ПС);
				НачалоМетода = РазобратьНачалоМетода(ПолнаяСигнатура);
				Если НачалоМетода <> Неопределено Тогда
					ТекущийМетод = НачалоМетода;
					ТекущийМетод.НомерСтрокиНачалаТела = Инд + 2; // Тело начинается со следующей строки
					СтрокиТела = Новый Массив;
					ГлубинаВложенности = 0;
					СобираемСигнатуру = Ложь;
				ИначеЕсли Инд - ИндексНачалаСигнатуры > 10 Тогда
					// Защита от бесконечного цикла - слишком много строк
					СобираемСигнатуру = Ложь;
				КонецЕсли;
			Иначе
				НачалоМетода = РазобратьНачалоМетода(Обрезанная);
				Если НачалоМетода <> Неопределено Тогда
					ТекущийМетод = НачалоМетода;
					ТекущийМетод.НомерСтрокиНачалаТела = Инд + 2; // Тело начинается со следующей строки
					СтрокиТела = Новый Массив;
					ГлубинаВложенности = 0;
				ИначеЕсли ЭтоНезавершённаяСигнатураМетода(Обрезанная) Тогда
					// Начало метода, но сигнатура не завершена (нет закрывающей скобки)
					СобираемСигнатуру = Истина;
					СтрокиСигнатуры = Новый Массив;
					СтрокиСигнатуры.Добавить(Строка);
					ИндексНачалаСигнатуры = Инд;
				КонецЕсли;
			КонецЕсли;
		Иначе
			// Внутри определения метода
			Если ЭтоКонецМетода(Обрезанная, ТекущийМетод.ЭтоФункция) И ГлубинаВложенности = 0 Тогда
				ТекущийМетод.Тело = СтрСоединить(СтрокиТела, Символы.ПС);
				ТекущийМетод.КоличествоВозвратов = ПосчитатьВозвраты(ТекущийМетод.Тело);
				Контекст.Методы.Вставить(НРег(ТекущийМетод.Имя), ТекущийМетод);
				ТекущийМетод = Неопределено;
			Иначе
				ГлубинаВложенности = ГлубинаВложенности + ПолучитьДельтуВложенности(Обрезанная);
				СтрокиТела.Добавить(Строка);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Проверяет, является ли строка началом сигнатуры метода без закрывающей скобки.
// Например: "Функция ИмяМетода(Знач Параметр = """
Функция ЭтоНезавершённаяСигнатураМетода(Знач Обрезанная)
	
	ВРег = ВРег(Обрезанная);
	
	// Проверяем ключевое слово
	Если Не (СтрНачинаетсяС(ВРег, "ПРОЦЕДУРА ")
		Или СтрНачинаетсяС(ВРег, "ФУНКЦИЯ ")
		Или СтрНачинаетсяС(ВРег, "PROCEDURE ")
		Или СтрНачинаетсяС(ВРег, "FUNCTION ")) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Должна быть открывающая скобка
	Если СтрНайти(Обрезанная, "(") = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Не должно быть закрывающей скобки (без учёта кавычек)
	// Для простоты проверяем через НайтиПарнуюСкобку
	ПозОткр = СтрНайти(Обрезанная, "(");
	ПозЗакр = НайтиПарнуюСкобку(Обрезанная, ПозОткр);
	
	Возврат ПозЗакр = 0; // Скобка не закрыта
	
КонецФункции

// Пытается распарсить строку как начало определения процедуры/функции.
Функция РазобратьНачалоМетода(Знач Обрезанная)
	
	ВРег = ВРег(Обрезанная);
	
	ЭтоФункция = Ложь;
	КлючевоеСлово = "";
	
	Если СтрНачинаетсяС(ВРег, "ПРОЦЕДУРА ") Тогда
		КлючевоеСлово = "Процедура";
	ИначеЕсли СтрНачинаетсяС(ВРег, "ФУНКЦИЯ ") Тогда
		КлючевоеСлово = "Функция";
		ЭтоФункция = Истина;
	ИначеЕсли СтрНачинаетсяС(ВРег, "PROCEDURE ") Тогда
		КлючевоеСлово = "Procedure";
	ИначеЕсли СтрНачинаетсяС(ВРег, "FUNCTION ") Тогда
		КлючевоеСлово = "Function";
		ЭтоФункция = Истина;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	// Ищем открывающую скобку
	ПозСкобки = СтрНайти(Обрезанная, "(");
	Если ПозСкобки = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Извлекаем имя метода
	ПослеКлючевого = СокрЛП(Сред(Обрезанная, СтрДлина(КлючевоеСлово) + 1, ПозСкобки - СтрДлина(КлючевоеСлово) - 1));
	Если Не ЭтоИдентификатор(ПослеКлючевого) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Ищем закрывающую скобку
	ПозЗакр = НайтиПарнуюСкобку(Обрезанная, ПозСкобки);
	Если ПозЗакр = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Извлекаем параметры
	СтрПараметров = Сред(Обрезанная, ПозСкобки + 1, ПозЗакр - ПозСкобки - 1);
	Параметры = РазобратьПараметры(СтрПараметров);
	
	Метод = НовоеОписаниеМетода();
	Метод.Имя = ПослеКлючевого;
	Метод.Параметры = Параметры;
	Метод.ЭтоФункция = ЭтоФункция;
	
	Возврат Метод;
	
КонецФункции

// Проверяет, является ли строка концом метода.
Функция ЭтоКонецМетода(Знач Обрезанная, Знач ЭтоФункция)
	
	ВРег = ВРег(СокрЛП(Обрезанная));
	
	Если ЭтоФункция Тогда
		Возврат ВРег = "КОНЕЦФУНКЦИИ" Или ВРег = "ENDFUNCTION";
	Иначе
		Возврат ВРег = "КОНЕЦПРОЦЕДУРЫ" Или ВРег = "ENDPROCEDURE";
	КонецЕсли;
	
КонецФункции

// Парсит строку параметров: "Знач А, Б = 0, В"
Функция РазобратьПараметры(Знач СтрПараметров)
	
	Результат = Новый Массив;
	
	Если Не ЗначениеЗаполнено(СокрЛП(СтрПараметров)) Тогда
		Возврат Результат;
	КонецЕсли;
	
	Части = РазделитьНаВерхнемУровне(СтрПараметров, ",");
	
	Для Каждого Часть Из Части Цикл
		ОбрЧасть = СокрЛП(Часть);
		Если Не ЗначениеЗаполнено(ОбрЧасть) Тогда
			Продолжить;
		КонецЕсли;
		
		Парам = НовоеОписаниеПараметра();
		
		// Проверяем "Знач" / "Val"
		ВРегЧасть = ВРег(ОбрЧасть);
		Если СтрНачинаетсяС(ВРегЧасть, "ЗНАЧ ") Тогда
			Парам.ПоЗначению = Истина;
			ОбрЧасть = СокрЛП(Сред(ОбрЧасть, 6));
		ИначеЕсли СтрНачинаетсяС(ВРегЧасть, "VAL ") Тогда
			Парам.ПоЗначению = Истина;
			ОбрЧасть = СокрЛП(Сред(ОбрЧасть, 5));
		КонецЕсли;
		
		// Проверяем значение по умолчанию
		ПозРавно = СтрНайти(ОбрЧасть, "=");
		Если ПозРавно > 0 Тогда
			Парам.Имя = СокрЛП(Лев(ОбрЧасть, ПозРавно - 1));
			Парам.ЗначениеПоУмолчанию = СокрЛП(Сред(ОбрЧасть, ПозРавно + 1));
		Иначе
			Парам.Имя = ОбрЧасть;
		КонецЕсли;
		
		Результат.Добавить(Парам);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Считает количество операторов Возврат в теле метода.
Функция ПосчитатьВозвраты(Знач Тело)
	
	Кол = 0;
	Строки = СтрРазделить(Тело, Символы.ПС);
	
	Для Каждого Строка Из Строки Цикл
		Обрезанная = СокрЛП(Строка);
		Если СтрНачинаетсяС(Обрезанная, "//") Тогда
			Продолжить;
		КонецЕсли;
		Если НачинаетсяСКлючевогоСлова(Обрезанная, "Возврат")
			Или НачинаетсяСКлючевогоСлова(Обрезанная, "Return") Тогда
			Кол = Кол + 1;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Кол;
	
КонецФункции

#КонецОбласти

#Область ИзвлечениеОсновногоТела

// Извлекает код вне определений процедур/функций.
Функция ИзвлечьОсновноеТело(Контекст)
	
	Строки = СтрРазделить(Контекст.ИсходныйКод, Символы.ПС);
	ОсновныеСтроки = Новый Массив;
	КартаСтрок = Новый Массив;
	ВнутриМетода = Ложь;
	МетодЭтоФункция = Ложь;
	ГлубинаВложенности = 0;
	СобираемСигнатуру = Ложь;
	СтрокиСигнатуры = Новый Массив;
	ИндексНачалаСигнатуры = 0;
	
	Для Инд = 0 По Строки.ВГраница() Цикл
		Строка = Строки[Инд];
		Обрезанная = СокрЛП(Строка);
		
		Если СтрНачинаетсяС(Обрезанная, "&") И Не ВнутриМетода Тогда
			Продолжить; // Директива компиляции
		КонецЕсли;
		
		Если Не ВнутриМетода Тогда
			Если СобираемСигнатуру Тогда
				// Продолжаем собирать многострочную сигнатуру
				СтрокиСигнатуры.Добавить(Строка);
				// Объединяем с переводом строки для сохранения многострочных литералов
				ПолнаяСигнатура = СтрСоединить(СтрокиСигнатуры, Символы.ПС);
				НачалоМетода = РазобратьНачалоМетода(ПолнаяСигнатура);
				Если НачалоМетода <> Неопределено Тогда
					ВнутриМетода = Истина;
					МетодЭтоФункция = НачалоМетода.ЭтоФункция;
					ГлубинаВложенности = 0;
					СобираемСигнатуру = Ложь;
				ИначеЕсли Инд - ИндексНачалаСигнатуры > 10 Тогда
					// Защита от бесконечного цикла
					СобираемСигнатуру = Ложь;
				КонецЕсли;
			Иначе
				НачалоМетода = РазобратьНачалоМетода(Обрезанная);
				Если НачалоМетода <> Неопределено Тогда
					ВнутриМетода = Истина;
					МетодЭтоФункция = НачалоМетода.ЭтоФункция;
					ГлубинаВложенности = 0;
				ИначеЕсли ЭтоНезавершённаяСигнатураМетода(Обрезанная) Тогда
					// Начало метода, но сигнатура не завершена
					СобираемСигнатуру = Истина;
					СтрокиСигнатуры = Новый Массив;
					СтрокиСигнатуры.Добавить(Строка);
					ИндексНачалаСигнатуры = Инд;
				Иначе
					// Пропускаем директивы областей
					ВРег = ВРег(Обрезанная);
					Если СтрНачинаетсяС(ВРег, "#ОБЛАСТЬ") Или СтрНачинаетсяС(ВРег, "#КОНЕЦОБЛАСТИ")
						Или СтрНачинаетсяС(ВРег, "#REGION") Или СтрНачинаетсяС(ВРег, "#ENDREGION") Тогда
						Продолжить;
					КонецЕсли;
					ОсновныеСтроки.Добавить(Строка);
					КартаСтрок.Добавить(Инд + 1); // 1-based
				КонецЕсли;
			КонецЕсли;
		Иначе
			Если ЭтоКонецМетода(Обрезанная, МетодЭтоФункция) И ГлубинаВложенности = 0 Тогда
				ВнутриМетода = Ложь;
			Иначе
				ГлубинаВложенности = ГлубинаВложенности + ПолучитьДельтуВложенности(Обрезанная);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("Код, КартаСтрок",
		СтрСоединить(ОсновныеСтроки, Символы.ПС), КартаСтрок);
	
КонецФункции

#КонецОбласти

#Область ИнлайнингВызовов

// Рекурсивно заменяет вызовы определённых методов на инлайн-код.
// Сначала группирует многострочные выражения, обрабатывает как единое целое.
Функция ИнлайнитьВызовы(Контекст, Знач Код, Знач Глубина)
	
	Если Глубина > Контекст.МаксГлубина Тогда
		Возврат "// ОШИБКА ИНЛАЙНЕРА: превышена максимальная глубина инлайнинга (" 
			+ Формат(Контекст.МаксГлубина, "ЧГ=") + ")" + Символы.ПС + Код;
	КонецЕсли;
	
	// Нормализуем - склеиваем многострочные выражения
	КодНорм = НормализоватьМногострочныеВыражения(Код);
	
	Результат = КодНорм;
	Изменено = Истина;
	Итерация = 0;
	МаксИтераций = 100;
	
	Пока Изменено И Итерация < МаксИтераций Цикл
		Изменено = Ложь;
		Итерация = Итерация + 1;
		
		Строки = СтрРазделить(Результат, Символы.ПС);
		НовыеСтроки = Новый Массив;
		
		Для Каждого Строка Из Строки Цикл
			Развёрнутая = РазвернутьСтроку(Контекст, Строка, Глубина);
			Если Развёрнутая <> Неопределено Тогда
				НовыеСтроки.Добавить(Развёрнутая);
				Изменено = Истина;
			Иначе
				НовыеСтроки.Добавить(Строка);
			КонецЕсли;
		КонецЦикла;
		
		Результат = СтрСоединить(НовыеСтроки, Символы.ПС);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Нормализует код, склеивая многострочные выражения в однострочные.
// Многострочное выражение = строка с незакрытыми скобками + продолжения.
Функция НормализоватьМногострочныеВыражения(Знач Код)
	
	Код = СтрЗаменить(Код, Символы.ВК, "");
	Строки = СтрРазделить(Код, Символы.ПС);
	
	Результат = Новый Массив;
	Буфер = "";
	ВнутриЛитерала = Ложь;
	БалансСкобок = 0;
	
	Для Каждого Строка Из Строки Цикл
		Обрезанная = СокрЛП(Строка);
		
		// Комментарии не склеиваем
		Если СтрНачинаетсяС(Обрезанная, "//") Тогда
			Если ЗначениеЗаполнено(Буфер) Тогда
				// Комментарий внутри многострочного выражения - пропускаем
				Продолжить;
			Иначе
				Результат.Добавить(Строка);
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		// Строки-продолжения литералов (|...) не склеиваем с обычным кодом
		Если ЭтоПродолжениеМногострочнойСтроки(Строка) Тогда
			Если ЗначениеЗаполнено(Буфер) Тогда
				Буфер = Буфер + Символы.ПС + Строка;
			Иначе
				Результат.Добавить(Строка);
				// Обновляем состояние и продолжаем
				Анализ = АнализСостоянияСтроки(Строка, ВнутриЛитерала, Макс(БалансСкобок, 0));
				ВнутриЛитерала = Анализ.ВнутриЛитерала;
				БалансСкобок = Анализ.БалансСкобок;
				Продолжить;
			КонецЕсли;
			// Обновляем состояние
			Анализ = АнализСостоянияСтроки(Строка, ВнутриЛитерала, Макс(БалансСкобок, 0));
			ВнутриЛитерала = Анализ.ВнутриЛитерала;
			БалансСкобок = Анализ.БалансСкобок;
			// Если выражение завершилось (литерал закрылся) - сбрасываем буфер
			Если Анализ.МожноДобавитьМаркер Тогда
				Результат.Добавить(Буфер);
				Буфер = "";
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(Буфер) Тогда
			// Продолжаем начатое многострочное выражение
			Буфер = Буфер + " " + СокрЛП(Строка);
		Иначе
			// Начинаем новую строку/выражение
			Буфер = Строка;
		КонецЕсли;
		
		// Анализируем состояние
		Анализ = АнализСостоянияСтроки(Строка, ВнутриЛитерала, Макс(БалансСкобок, 0));
		ВнутриЛитерала = Анализ.ВнутриЛитерала;
		БалансСкобок = Анализ.БалансСкобок;
		
		// Если выражение завершено - добавляем в результат
		Если Анализ.МожноДобавитьМаркер Тогда
			Результат.Добавить(Буфер);
			Буфер = "";
		КонецЕсли;
	КонецЦикла;
	
	// Если что-то осталось - добавляем
	Если ЗначениеЗаполнено(Буфер) Тогда
		Результат.Добавить(Буфер);
	КонецЕсли;
	
	Возврат СтрСоединить(Результат, Символы.ПС);
	
КонецФункции

// Инлайнит вызовы с отслеживанием маппинга строк.
Функция ИнлайнитьВызовыСКартой(Контекст, Знач Код, Знач КартаСтрок, Знач Глубина)
	
	Если Глубина > Контекст.МаксГлубина Тогда
		СтрОшибки = "// ОШИБКА ИНЛАЙНЕРА: превышена максимальная глубина инлайнинга (" 
			+ Формат(Контекст.МаксГлубина, "ЧГ=") + ")";
		НоваяКарта = Новый Массив;
		Если КартаСтрок.Количество() > 0 Тогда
			НоваяКарта.Добавить(КартаСтрок[0]);
		Иначе
			НоваяКарта.Добавить(1);
		КонецЕсли;
		Для Каждого Элемент Из КартаСтрок Цикл
			НоваяКарта.Добавить(Элемент);
		КонецЦикла;
		Возврат Новый Структура("Код, Карта", СтрОшибки + Символы.ПС + Код, НоваяКарта);
	КонецЕсли;
	
	// Нормализуем многострочные выражения с сохранением карты
	РезНорм = НормализоватьМногострочныеВыраженияСКартой(Код, КартаСтрок);
	
	ТекСтроки = СтрРазделить(РезНорм.Код, Символы.ПС);
	ТекКарта = Новый Массив;
	Для Каждого Элемент Из РезНорм.Карта Цикл
		ТекКарта.Добавить(Элемент);
	КонецЦикла;
	
	// Дополняем карту если короче
	Пока ТекКарта.Количество() < ТекСтроки.Количество() Цикл
		Если ТекКарта.Количество() > 0 Тогда
			ТекКарта.Добавить(ТекКарта[ТекКарта.ВГраница()]);
		Иначе
			ТекКарта.Добавить(1);
		КонецЕсли;
	КонецЦикла;
	
	Изменено = Истина;
	Итерация = 0;
	МаксИтераций = 100;
	
	Пока Изменено И Итерация < МаксИтераций Цикл
		Изменено = Ложь;
		Итерация = Итерация + 1;
		
		НовыеСтроки = Новый Массив;
		НоваяКарта = Новый Массив;
		
		Для Инд = 0 По ТекСтроки.ВГраница() Цикл
			Строка = ТекСтроки[Инд];
			ОригНомер = 1;
			Если Инд < ТекКарта.Количество() Тогда
				ОригНомер = ТекКарта[Инд];
			ИначеЕсли ТекКарта.Количество() > 0 Тогда
				ОригНомер = ТекКарта[ТекКарта.ВГраница()];
			КонецЕсли;
			
			Развёрнутая = РазвернутьСтроку(Контекст, Строка, Глубина);
			
			Если Развёрнутая <> Неопределено Тогда
				Части = СтрРазделить(Развёрнутая, Символы.ПС);
				Для Каждого Часть Из Части Цикл
					НовыеСтроки.Добавить(Часть);
					НоваяКарта.Добавить(ОригНомер);
				КонецЦикла;
				Изменено = Истина;
			Иначе
				НовыеСтроки.Добавить(Строка);
				НоваяКарта.Добавить(ОригНомер);
			КонецЕсли;
		КонецЦикла;
		
		ТекСтроки = НовыеСтроки;
		ТекКарта = НоваяКарта;
	КонецЦикла;
	
	Возврат Новый Структура("Код, Карта",
		СтрСоединить(ТекСтроки, Символы.ПС), ТекКарта);
	
КонецФункции

// Нормализует многострочные выражения с сохранением карты строк.
Функция НормализоватьМногострочныеВыраженияСКартой(Знач Код, Знач КартаСтрок)
	
	Код = СтрЗаменить(Код, Символы.ВК, "");
	Строки = СтрРазделить(Код, Символы.ПС);
	
	// Копируем карту
	ОригКарта = Новый Массив;
	Для Каждого Эл Из КартаСтрок Цикл
		ОригКарта.Добавить(Эл);
	КонецЦикла;
	// Дополняем если короче
	Пока ОригКарта.Количество() < Строки.Количество() Цикл
		Если ОригКарта.Количество() > 0 Тогда
			ОригКарта.Добавить(ОригКарта[ОригКарта.ВГраница()]);
		Иначе
			ОригКарта.Добавить(1);
		КонецЕсли;
	КонецЦикла;
	
	Результат = Новый Массив;
	НоваяКарта = Новый Массив;
	Буфер = "";
	БуферНомер = 0;
	ВнутриЛитерала = Ложь;
	БалансСкобок = 0;
	
	Для Инд = 0 По Строки.ВГраница() Цикл
		Строка = Строки[Инд];
		НомерСтроки = ОригКарта[Инд];
		Обрезанная = СокрЛП(Строка);
		
		// Комментарии не склеиваем
		Если СтрНачинаетсяС(Обрезанная, "//") Тогда
			Если ЗначениеЗаполнено(Буфер) Тогда
				// Комментарий внутри многострочного выражения - пропускаем
				Продолжить;
			Иначе
				Результат.Добавить(Строка);
				НоваяКарта.Добавить(НомерСтроки);
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		// Строки-продолжения литералов (|...)
		Если ЭтоПродолжениеМногострочнойСтроки(Строка) Тогда
			Если ЗначениеЗаполнено(Буфер) Тогда
				Буфер = Буфер + Символы.ПС + Строка;
			Иначе
				Результат.Добавить(Строка);
				НоваяКарта.Добавить(НомерСтроки);
				// Обновляем состояние и продолжаем
				Анализ = АнализСостоянияСтроки(Строка, ВнутриЛитерала, Макс(БалансСкобок, 0));
				ВнутриЛитерала = Анализ.ВнутриЛитерала;
				БалансСкобок = Анализ.БалансСкобок;
				Продолжить;
			КонецЕсли;
			// Обновляем состояние
			Анализ = АнализСостоянияСтроки(Строка, ВнутриЛитерала, Макс(БалансСкобок, 0));
			ВнутриЛитерала = Анализ.ВнутриЛитерала;
			БалансСкобок = Анализ.БалансСкобок;
			// Если выражение завершилось (литерал закрылся) - сбрасываем буфер
			Если Анализ.МожноДобавитьМаркер Тогда
				Результат.Добавить(Буфер);
				НоваяКарта.Добавить(БуферНомер);
				Буфер = "";
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(Буфер) Тогда
			// Продолжаем начатое многострочное выражение
			Буфер = Буфер + " " + СокрЛП(Строка);
		Иначе
			// Начинаем новую строку/выражение
			Буфер = Строка;
			БуферНомер = НомерСтроки;
		КонецЕсли;
		
		// Анализируем состояние
		Анализ = АнализСостоянияСтроки(Строка, ВнутриЛитерала, Макс(БалансСкобок, 0));
		ВнутриЛитерала = Анализ.ВнутриЛитерала;
		БалансСкобок = Анализ.БалансСкобок;
		
		// Если выражение завершено - добавляем в результат
		Если Анализ.МожноДобавитьМаркер Тогда
			Результат.Добавить(Буфер);
			НоваяКарта.Добавить(БуферНомер);
			Буфер = "";
		КонецЕсли;
	КонецЦикла;
	
	// Если что-то осталось - добавляем
	Если ЗначениеЗаполнено(Буфер) Тогда
		Результат.Добавить(Буфер);
		НоваяКарта.Добавить(БуферНомер);
	КонецЕсли;
	
	Возврат Новый Структура("Код, Карта", СтрСоединить(Результат, Символы.ПС), НоваяКарта);
	
КонецФункции

// Пытается развернуть вызовы методов в одной строке.
Функция РазвернутьСтроку(Контекст, Знач Строка, Знач Глубина)
	
	Обрезанная = СокрЛП(Строка);
	
	// Пропускаем комментарии
	Если СтрНачинаетсяС(Обрезанная, "//") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Определяем отступ
	Отступ = ПолучитьОтступ(Строка);
	
	// Извлекаем маркер //@@N если есть
	РезМаркера = ИзвлечьМаркер(Обрезанная);
	ОбрБезМаркера = РезМаркера.ТекстБезМаркера;
	
	// 1. Проверяем вызов процедуры: ИмяМетода(аргументы);
	РезВызова = РаспознатьВызовПроцедуры(ОбрБезМаркера);
	Если РезВызова <> Неопределено Тогда
		Метод = Контекст.Методы.Получить(НРег(РезВызова.ИмяМетода));
		Если Метод <> Неопределено И Не Метод.ЭтоФункция Тогда
			Аргументы = РазделитьАргументы(РезВызова.СтрАргументов);
			Возврат ИнлайнитьВызовПроцедуры(Контекст, Метод, Аргументы, Отступ, Глубина);
		КонецЕсли;
	КонецЕсли;
	
	// 2. Проверяем присваивание с вызовом функции: Переменная = ИмяФункции(аргументы);
	РезПрисв = РаспознатьПрисваиваниеСВызовом(ОбрБезМаркера);
	Если РезПрисв <> Неопределено Тогда
		Метод = Контекст.Методы.Получить(НРег(РезПрисв.ИмяМетода));
		Если Метод <> Неопределено И Метод.ЭтоФункция Тогда
			Аргументы = РазделитьАргументы(РезПрисв.СтрАргументов);
			Возврат ИнлайнитьВызовФункции(Контекст, Метод, Аргументы, РезПрисв.ИмяПеременной, Отступ, Глубина);
		КонецЕсли;
	КонецЕсли;
	
	// 3. Проверяем встроенные вызовы функций в произвольных выражениях
	РезВстр = РазвернутьВстроенныеВызовы(Контекст, Строка, Глубина);
	Если РезВстр <> Неопределено Тогда
		Возврат РезВстр;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

#КонецОбласти

#Область РаспознаваниеПаттернов

// Распознаёт вызов процедуры: ИмяМетода(аргументы);
Функция РаспознатьВызовПроцедуры(Знач Обрезанная)
	
	// Ищем идентификатор в начале строки
	ИмяМетода = ИзвлечьИдентификаторВНачале(Обрезанная);
	Если Не ЗначениеЗаполнено(ИмяМетода) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Остаток = СокрЛ(Сред(Обрезанная, СтрДлина(ИмяМетода) + 1));
	
	// Должна быть открывающая скобка
	Если Не СтрНачинаетсяС(Остаток, "(") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Ищем парную скобку
	ПозЗакр = НайтиПарнуюСкобку(Остаток, 1);
	Если ПозЗакр = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// После закрывающей скобки может быть только ; и пробелы
	ПослеСкобки = СокрЛП(Сред(Остаток, ПозЗакр + 1));
	Если ПослеСкобки <> "" И ПослеСкобки <> ";" Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтрАрг = Сред(Остаток, 2, ПозЗакр - 2);
	
	Возврат Новый Структура("ИмяМетода, СтрАргументов", ИмяМетода, СтрАрг);
	
КонецФункции

// Распознаёт присваивание с вызовом функции: Переменная = ИмяФункции(аргументы);
Функция РаспознатьПрисваиваниеСВызовом(Знач Обрезанная)
	
	// Ищем идентификатор (переменная)
	ИмяПеременной = ИзвлечьИдентификаторВНачале(Обрезанная);
	Если Не ЗначениеЗаполнено(ИмяПеременной) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Остаток = СокрЛ(Сред(Обрезанная, СтрДлина(ИмяПеременной) + 1));
	
	// Должен быть знак =
	Если Не СтрНачинаетсяС(Остаток, "=") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Остаток = СокрЛ(Сред(Остаток, 2));
	
	// Должен быть идентификатор (имя функции)
	ИмяМетода = ИзвлечьИдентификаторВНачале(Остаток);
	Если Не ЗначениеЗаполнено(ИмяМетода) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Остаток = СокрЛ(Сред(Остаток, СтрДлина(ИмяМетода) + 1));
	
	// Должна быть открывающая скобка
	Если Не СтрНачинаетсяС(Остаток, "(") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Ищем парную скобку
	ПозЗакр = НайтиПарнуюСкобку(Остаток, 1);
	Если ПозЗакр = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// После закрывающей скобки может быть только ; и пробелы
	ПослеСкобки = СокрЛП(Сред(Остаток, ПозЗакр + 1));
	Если ПослеСкобки <> "" И ПослеСкобки <> ";" Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтрАрг = Сред(Остаток, 2, ПозЗакр - 2);
	
	Возврат Новый Структура("ИмяПеременной, ИмяМетода, СтрАргументов",
		ИмяПеременной, ИмяМетода, СтрАрг);
	
КонецФункции

// Ищет и разворачивает вызовы функций, встроенные в выражения.
Функция РазвернутьВстроенныеВызовы(Контекст, Знач Строка, Знач Глубина)
	
	Обрезанная = СокрЛП(Строка);
	Если СтрНачинаетсяС(Обрезанная, "//") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Отступ = ПолучитьОтступ(Строка);
	
	// Убираем маркер //@@N для проверок
	РезМаркера = ИзвлечьМаркер(Обрезанная);
	ОбрБезМаркера = РезМаркера.ТекстБезМаркера;
	
	// Ищем первый вызов известного метода в строке
	Для Каждого КлючЗначение Из Контекст.Методы Цикл
		Метод = КлючЗначение.Значение;
		Если Не Метод.ЭтоФункция Тогда
			Продолжить;
		КонецЕсли;
		
		// Ищем вызов этой функции в строке
		ПозВызова = НайтиВызовМетодаВСтроке(ОбрБезМаркера, Метод.Имя);
		Если ПозВызова = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		// Находим позицию открывающей скобки
		ПозОткр = СтрНайтиПосле(ОбрБезМаркера, "(", ПозВызова + СтрДлина(Метод.Имя));
		Если ПозОткр = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		// Находим парную закрывающую скобку
		ПозЗакр = НайтиПарнуюСкобку(ОбрБезМаркера, ПозОткр);
		Если ПозЗакр = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		// Проверяем, что это не чистое присваивание (уже обработано)
		ПередВызовом = СокрЛП(Лев(ОбрБезМаркера, ПозВызова - 1));
		ОбрБезТочкиЗапятой = СокрП(СтрЗаменить(ОбрБезМаркера, ";", ""));
		Если ЭтоПростоеПрисваивание(ПередВызовом) И ПозЗакр = СтрДлина(ОбрБезТочкиЗапятой) Тогда
			Продолжить; // Чистое присваивание
		КонецЕсли;
		
		СтрАрг = Сред(ОбрБезМаркера, ПозОткр + 1, ПозЗакр - ПозОткр - 1);
		Аргументы = РазделитьАргументы(СтрАрг);
		
		// Генерируем уникальную переменную результата
		Контекст.СчётчикИнлайна = Контекст.СчётчикИнлайна + 1;
		ПеремРезультата = "_р" + Формат(Контекст.СчётчикИнлайна, "ЧГ=");
		
		// Инлайним вызов функции
		ИнлайнТело = ИнлайнитьВызовФункции(Контекст, Метод, Аргументы, ПеремРезультата, Отступ, Глубина);
		
		// Заменяем вызов функции в строке на переменную результата
		ПолныйВызов = Сред(ОбрБезМаркера, ПозВызова, ПозЗакр - ПозВызова + 1);
		НоваяСтрока = Отступ + ЗаменитьВнеСтроковыхЛитералов(Обрезанная, ПолныйВызов, ПеремРезультата);
		
		Возврат ИнлайнТело + Символы.ПС + НоваяСтрока;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Находит позицию вызова метода в строке (не как отдельный идентификатор, а как вызов).
Функция НайтиВызовМетодаВСтроке(Знач Строка, Знач ИмяМетода)
	
	ДлинаИмени = СтрДлина(ИмяМетода);
	ИмяВРег = ВРег(ИмяМетода);
	СтрокаВРег = ВРег(Строка);
	
	Позиция = 1;
	Пока Позиция <= СтрДлина(Строка) - ДлинаИмени + 1 Цикл
		// Пропускаем строковые литералы
		Символ = Сред(Строка, Позиция, 1);
		Если Символ = """" Тогда
			Позиция = ПропуститьСтроковыйЛитерал(Строка, Позиция);
			Продолжить;
		ИначеЕсли Символ = "'" Тогда
			Позиция = ПропуститьДатуЛитерал(Строка, Позиция);
			Продолжить;
		КонецЕсли;
		
		// Проверяем совпадение имени
		Фрагмент = Сред(СтрокаВРег, Позиция, ДлинаИмени);
		Если Фрагмент = ИмяВРег Тогда
			// Проверяем, что перед ним не буква/цифра
			Если Позиция > 1 Тогда
				СимволПеред = Сред(Строка, Позиция - 1, 1);
				Если ЭтоСимволИдентификатора(СимволПеред) Тогда
					Позиция = Позиция + 1;
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			// Проверяем, что после имени идёт (
			ПозПосле = Позиция + ДлинаИмени;
			// Пропускаем пробелы
			Пока ПозПосле <= СтрДлина(Строка) И Сред(Строка, ПозПосле, 1) = " " Цикл
				ПозПосле = ПозПосле + 1;
			КонецЦикла;
			
			Если ПозПосле <= СтрДлина(Строка) И Сред(Строка, ПозПосле, 1) = "(" Тогда
				Возврат Позиция;
			КонецЕсли;
		КонецЕсли;
		
		Позиция = Позиция + 1;
	КонецЦикла;
	
	Возврат 0;
	
КонецФункции

// Проверяет, является ли текст перед вызовом простым присваиванием (идентификатор =).
Функция ЭтоПростоеПрисваивание(Знач Текст)
	
	Если Не ЗначениеЗаполнено(Текст) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Обрезанная = СокрП(Текст);
	Если Не СтрЗаканчиваетсяНа(Обрезанная, "=") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Идент = СокрЛП(Лев(Обрезанная, СтрДлина(Обрезанная) - 1));
	Возврат ЭтоИдентификатор(Идент);
	
КонецФункции

#КонецОбласти

#Область ИнлайнингМетодов

// Инлайнит вызов процедуры.
Функция ИнлайнитьВызовПроцедуры(Контекст, Метод, Аргументы, Отступ, Глубина)
	
	Контекст.СчётчикИнлайна = Контекст.СчётчикИнлайна + 1;
	Суффикс = Контекст.СчётчикИнлайна;
	
	Строки = Новый Массив;
	Строки.Добавить(Отступ + "// Инлайн: " + Метод.Имя + "(" + СтрСоединить(Аргументы, ", ") + ")");
	
	// Присваиваем параметры
	СтрокиПарам = Новый Массив;
	КартаПарам = ПостроитьКартуПараметров(Метод, Аргументы, Суффикс, Отступ, СтрокиПарам);
	
	// Инлайним вложенные вызовы в присваиваниях параметров
	Если СтрокиПарам.Количество() > 0 Тогда
		ИнлайнПарам = ИнлайнитьВызовы(Контекст, СтрСоединить(СтрокиПарам, Символы.ПС), Глубина + 1);
		Для Каждого Стр Из СтрРазделить(ИнлайнПарам, Символы.ПС) Цикл
			Строки.Добавить(Стр);
		КонецЦикла;
	КонецЕсли;
	
	// Подставляем тело с заменой параметров
	Тело = ПодставитьПараметры(Метод.Тело, КартаПарам);
	
	// Добавляем маркеры //@@N
	ТелоСМаркерами = ДобавитьМаркерыТела(Тело, Метод.НомерСтрокиНачалаТела);
	
	// Инлайним вложенные вызовы в теле
	ИнлайнТело = ИнлайнитьВызовы(Контекст, ТелоСМаркерами, Глубина + 1);
	
	// Добавляем тело с отступом
	Для Каждого СтрокаТела Из СтрРазделить(ИнлайнТело, Символы.ПС) Цикл
		Если ЗначениеЗаполнено(СокрЛП(СтрокаТела)) Тогда
			Строки.Добавить(Отступ + СокрЛ(СтрокаТела));
		Иначе
			Строки.Добавить("");
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрСоединить(Строки, Символы.ПС);
	
КонецФункции

// Инлайнит вызов функции.
Функция ИнлайнитьВызовФункции(Контекст, Метод, Аргументы, ПеремРезультата, Отступ, Глубина)
	
	Контекст.СчётчикИнлайна = Контекст.СчётчикИнлайна + 1;
	Суффикс = Контекст.СчётчикИнлайна;
	
	Строки = Новый Массив;
	Строки.Добавить(Отступ + "// Инлайн: " + ПеремРезультата + " = " + Метод.Имя 
		+ "(" + СтрСоединить(Аргументы, ", ") + ")");
	
	// Присваиваем параметры
	СтрокиПарам = Новый Массив;
	КартаПарам = ПостроитьКартуПараметров(Метод, Аргументы, Суффикс, Отступ, СтрокиПарам);
	
	// Инлайним вложенные вызовы в присваиваниях параметров
	Если СтрокиПарам.Количество() > 0 Тогда
		ИнлайнПарам = ИнлайнитьВызовы(Контекст, СтрСоединить(СтрокиПарам, Символы.ПС), Глубина + 1);
		Для Каждого Стр Из СтрРазделить(ИнлайнПарам, Символы.ПС) Цикл
			Строки.Добавить(Стр);
		КонецЦикла;
	КонецЕсли;
	
	// Подставляем тело с заменой параметров
	Тело = ПодставитьПараметры(Метод.Тело, КартаПарам);
	
	// Добавляем маркеры //@@N
	Тело = ДобавитьМаркерыТела(Тело, Метод.НомерСтрокиНачалаТела);
	
	// Обрабатываем Возврат
	Если Метод.КоличествоВозвратов <= 1 Тогда
		Тело = ЗаменитьПростойВозврат(Тело, ПеремРезультата);
	Иначе
		Тело = ЗаменитьМножественныеВозвраты(Тело, ПеремРезультата, Суффикс);
	КонецЕсли;
	
	// Инлайним вложенные вызовы в теле
	ИнлайнТело = ИнлайнитьВызовы(Контекст, Тело, Глубина + 1);
	
	// Добавляем тело с отступом
	Для Каждого СтрокаТела Из СтрРазделить(ИнлайнТело, Символы.ПС) Цикл
		Если ЗначениеЗаполнено(СокрЛП(СтрокаТела)) Тогда
			Строки.Добавить(Отступ + СокрЛ(СтрокаТела));
		Иначе
			Строки.Добавить("");
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрСоединить(Строки, Символы.ПС);
	
КонецФункции

#КонецОбласти

#Область ПодстановкаПараметров

// Создаёт маппинг параметров → уникальные переменные и генерирует присваивания.
Функция ПостроитьКартуПараметров(Метод, Аргументы, Суффикс, Отступ, СтрокиВыхода)
	
	КартаПарам = Новый Соответствие; // ИмяПарамНРег → УникальноеИмя
	
	Для Инд = 0 По Метод.Параметры.ВГраница() Цикл
		Парам = Метод.Параметры[Инд];
		УникальноеИмя = "_п" + Формат(Суффикс, "ЧГ=") + "_" + Парам.Имя;
		КартаПарам.Вставить(НРег(Парам.Имя), УникальноеИмя);
		
		Значение = "";
		Если Инд < Аргументы.Количество() И ЗначениеЗаполнено(СокрЛП(Аргументы[Инд])) Тогда
			Значение = Аргументы[Инд];
		ИначеЕсли Парам.ЗначениеПоУмолчанию <> Неопределено Тогда
			Значение = Парам.ЗначениеПоУмолчанию;
		Иначе
			Значение = "Неопределено";
		КонецЕсли;
		
		СтрокиВыхода.Добавить(Отступ + УникальноеИмя + " = " + Значение + ";");
	КонецЦикла;
	
	Возврат КартаПарам;
	
КонецФункции

// Заменяет имена параметров в теле метода на уникальные переменные.
// Учитывает многострочные строковые литералы.
Функция ПодставитьПараметры(Знач Тело, КартаПарам)
	
	Если КартаПарам.Количество() = 0 Тогда
		Возврат Тело;
	КонецЕсли;
	
	Строки = СтрРазделить(Тело, Символы.ПС);
	Результат = Новый Массив;
	ВнутриСтроки = Ложь; // Отслеживаем, находимся ли внутри незакрытого строкового литерала
	
	Для Каждого Строка Из Строки Цикл
		РезПодстановки = ПодставитьПараметрыВСтрокеСКонтекстом(Строка, КартаПарам, ВнутриСтроки);
		Результат.Добавить(РезПодстановки.Строка);
		ВнутриСтроки = РезПодстановки.ВнутриСтроки;
	КонецЦикла;
	
	Возврат СтрСоединить(Результат, Символы.ПС);
	
КонецФункции

// Заменяет параметры в одной строке с учётом контекста многострочных литералов.
// Параметры:
//   Строка - текущая строка
//   КартаПарам - соответствие параметров
//   ВнутриСтроки - находимся ли в начале строки внутри незакрытого строкового литерала
// Возврат:
//   Структура с полями Строка и ВнутриСтроки (состояние на конец строки)
Функция ПодставитьПараметрыВСтрокеСКонтекстом(Знач Строка, КартаПарам, Знач ВнутриСтроки)
	
	Сегменты = РазбитьСтрокуНаСегментыСКонтекстом(Строка, ВнутриСтроки);
	Результат = "";
	
	Для Каждого Сегмент Из Сегменты.Сегменты Цикл
		Если Сегмент.Тип = "код" Тогда
			Код = Сегмент.Текст;
			Для Каждого КлючЗначение Из КартаПарам Цикл
				Код = ЗаменитьИдентификатор(Код, КлючЗначение.Ключ, КлючЗначение.Значение);
			КонецЦикла;
			Результат = Результат + Код;
		Иначе
			Результат = Результат + Сегмент.Текст;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("Строка, ВнутриСтроки", Результат, Сегменты.ВнутриСтроки);
	
КонецФункции

// Заменяет параметры в одной строке, пропуская строковые литералы и комментарии.
// Устаревшая функция для обратной совместимости.
Функция ПодставитьПараметрыВСтроке(Знач Строка, КартаПарам)
	
	Сегменты = РазбитьСтрокуНаСегменты(Строка);
	Результат = "";
	
	Для Каждого Сегмент Из Сегменты Цикл
		Если Сегмент.Тип = "код" Тогда
			Код = Сегмент.Текст;
			Для Каждого КлючЗначение Из КартаПарам Цикл
				Код = ЗаменитьИдентификатор(Код, КлючЗначение.Ключ, КлючЗначение.Значение);
			КонецЦикла;
			Результат = Результат + Код;
		Иначе
			Результат = Результат + Сегмент.Текст;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Заменяет подстроку в коде, игнорируя содержимое строковых литералов.
Функция ЗаменитьВнеСтроковыхЛитералов(Знач Код, Знач ЧтоИскать, Знач НаЧтоЗаменить)
	
	ДлинаИскомого = СтрДлина(ЧтоИскать);
	Результат = "";
	Позиция = 1;
	ВнутриСтроки = Ложь;
	
	Пока Позиция <= СтрДлина(Код) Цикл
		ТекСимвол = Сред(Код, Позиция, 1);
		
		// Обработка строковых литералов
		Если ТекСимвол = """" Тогда
			Если ВнутриСтроки Тогда
				// Проверяем экранированную кавычку
				Если Позиция + 1 <= СтрДлина(Код) И Сред(Код, Позиция + 1, 1) = """" Тогда
					Результат = Результат + """""";
					Позиция = Позиция + 2;
					Продолжить;
				Иначе
					ВнутриСтроки = Ложь;
				КонецЕсли;
			Иначе
				ВнутриСтроки = Истина;
			КонецЕсли;
			Результат = Результат + ТекСимвол;
			Позиция = Позиция + 1;
			Продолжить;
		КонецЕсли;
		
		// Внутри строки - просто копируем символ
		Если ВнутриСтроки Тогда
			Результат = Результат + ТекСимвол;
			Позиция = Позиция + 1;
			Продолжить;
		КонецЕсли;
		
		// Вне строки - ищем подстроку для замены
		Если Позиция + ДлинаИскомого - 1 <= СтрДлина(Код) Тогда
			Фрагмент = Сред(Код, Позиция, ДлинаИскомого);
			Если Фрагмент = ЧтоИскать Тогда
				Результат = Результат + НаЧтоЗаменить;
				Позиция = Позиция + ДлинаИскомого;
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		Результат = Результат + ТекСимвол;
		Позиция = Позиция + 1;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Заменяет идентификатор в коде как отдельное слово (с учётом кириллицы).
Функция ЗаменитьИдентификатор(Знач Код, Знач ИмяНРег, Знач Замена)
	
	ДлинаИмени = СтрДлина(ИмяНРег);
	КодНРег = НРег(Код);
	Результат = "";
	Позиция = 1;
	ВнутриСтроки = Ложь;
	
	Пока Позиция <= СтрДлина(Код) Цикл
		ТекСимвол = Сред(Код, Позиция, 1);
		
		// Обработка строковых литералов
		Если ТекСимвол = """" Тогда
			Если ВнутриСтроки Тогда
				// Проверяем экранированную кавычку
				Если Позиция + 1 <= СтрДлина(Код) И Сред(Код, Позиция + 1, 1) = """" Тогда
					Результат = Результат + """""";
					Позиция = Позиция + 2;
					Продолжить;
				Иначе
					ВнутриСтроки = Ложь;
				КонецЕсли;
			Иначе
				ВнутриСтроки = Истина;
			КонецЕсли;
			Результат = Результат + ТекСимвол;
			Позиция = Позиция + 1;
			Продолжить;
		КонецЕсли;
		
		// Внутри строки - просто копируем символ
		Если ВнутриСтроки Тогда
			Результат = Результат + ТекСимвол;
			Позиция = Позиция + 1;
			Продолжить;
		КонецЕсли;
		
		// Вне строки - ищем идентификатор
		Если Позиция + ДлинаИмени - 1 <= СтрДлина(Код) Тогда
			Фрагмент = Сред(КодНРег, Позиция, ДлинаИмени);
			Если Фрагмент = ИмяНРег Тогда
				// Проверяем границы слова
				ПередОк = Истина;
				ПослеОк = Истина;
				
				Если Позиция > 1 Тогда
					СимволПеред = Сред(Код, Позиция - 1, 1);
					Если ЭтоСимволИдентификатора(СимволПеред) Тогда
						ПередОк = Ложь;
					КонецЕсли;
				КонецЕсли;
				
				ПозПосле = Позиция + ДлинаИмени;
				Если ПозПосле <= СтрДлина(Код) Тогда
					СимволПосле = Сред(Код, ПозПосле, 1);
					Если ЭтоСимволИдентификатора(СимволПосле) Тогда
						ПослеОк = Ложь;
					КонецЕсли;
				КонецЕсли;
				
				Если ПередОк И ПослеОк Тогда
					Результат = Результат + Замена;
					Позиция = Позиция + ДлинаИмени;
					Продолжить;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Результат = Результат + ТекСимвол;
		Позиция = Позиция + 1;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ОбработкаВозвратов

// Добавляет маркеры //@@N к каждой строке тела метода.
// Маркер добавляется только когда выражение полностью завершено (литералы закрыты, скобки сбалансированы).
// Для многострочных выражений маркер ставится на последней строке с номером первой.
Функция ДобавитьМаркерыТела(Знач Тело, Знач НомерНачалаТела)
	
	// Убираем \r для корректной работы с Windows-переносами
	Тело = СтрЗаменить(Тело, Символы.ВК, "");
	Строки = СтрРазделить(Тело, Символы.ПС);
	
	ВнутриЛитерала = Ложь;
	БалансСкобок = 0;
	НомерНачалаВыражения = 0; // Номер строки, где началось незавершённое выражение
	
	Для Инд = 0 По Строки.ВГраница() Цикл
		Строка = СокрП(Строки[Инд]);
		НомерТекущейСтроки = НомерНачалаТела + Инд;
		
		// Если начинается новое выражение - запоминаем номер строки
		Если Не ВнутриЛитерала И БалансСкобок <= 0 Тогда
			НомерНачалаВыражения = НомерТекущейСтроки;
		КонецЕсли;
		
		// Анализируем строку
		Анализ = АнализСостоянияСтроки(Строка, ВнутриЛитерала, Макс(БалансСкобок, 0));
		ВнутриЛитерала = Анализ.ВнутриЛитерала;
		БалансСкобок = Анализ.БалансСкобок;
		
		Если Анализ.МожноДобавитьМаркер Тогда
			// Выражение завершено - добавляем маркер с номером начала выражения
			Строки[Инд] = Строка + " //@@" + Формат(НомерНачалаВыражения, "ЧГ=");
		Иначе
			// Выражение не завершено - маркер не добавляем
			Строки[Инд] = Строка;
		КонецЕсли;
	КонецЦикла;
	
	// Если последняя строка осталась без маркера (незавершённое выражение из-за ошибки в коде),
	// принудительно добавляем маркер чтобы не терять связь с исходным кодом
	Если Строки.Количество() > 0 Тогда
		ПоследняяСтрока = Строки[Строки.ВГраница()];
		Если СтрНайти(ПоследняяСтрока, "//@@") = 0 Тогда
			Строки[Строки.ВГраница()] = ПоследняяСтрока + " //@@" + Формат(НомерНачалаВыражения, "ЧГ=");
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтрСоединить(Строки, Символы.ПС);
	
КонецФункции

// Проверяет, закрывается ли строковый литерал на этой строке (внутри продолжения).
// Строка - продолжение, начинающееся в незакрытом литерале.
Функция СтрокаЗакрываетсяНаЭтойСтроке(Знач Строка)
	
	// Ищем закрывающую кавычку (не экранированную) в строке
	КоличествоКавычек = 0;
	Поз = 1;
	
	Пока Поз <= СтрДлина(Строка) Цикл
		Символ = Сред(Строка, Поз, 1);
		Если Символ = """" Тогда
			КоличествоКавычек = КоличествоКавычек + 1;
			// Проверяем экранированную кавычку ""
			Если Поз + 1 <= СтрДлина(Строка) И Сред(Строка, Поз + 1, 1) = """" Тогда
				КоличествоКавычек = КоличествоКавычек + 1;
				Поз = Поз + 1; // Пропускаем вторую кавычку
			КонецЕсли;
		КонецЕсли;
		Поз = Поз + 1;
	КонецЦикла;
	
	// Нечётное количество кавычек = строка закрылась
	Возврат КоличествоКавычек % 2 = 1;
	
КонецФункции

// Проверяет, открывает ли строка незакрытый строковый литерал.
// Возвращает Истина, если строка заканчивается внутри открытого литерала.
Функция СтрокаОткрываетНезакрытыйЛитерал(Знач Строка)
	
	ВСтроке = Ложь;
	ВДате = Ложь;
	Поз = 1;
	
	Пока Поз <= СтрДлина(Строка) Цикл
		Символ = Сред(Строка, Поз, 1);
		
		Если ВСтроке Тогда
			Если Символ = """" Тогда
				// Проверяем экранированную кавычку ""
				Если Поз + 1 <= СтрДлина(Строка) И Сред(Строка, Поз + 1, 1) = """" Тогда
					Поз = Поз + 1; // Пропускаем вторую кавычку
				Иначе
					ВСтроке = Ложь; // Строка закрыта
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ВДате Тогда
			Если Символ = "'" Тогда
				ВДате = Ложь;
			КонецЕсли;
		ИначеЕсли Символ = """" Тогда
			ВСтроке = Истина;
		ИначеЕсли Символ = "'" Тогда
			ВДате = Истина;
		ИначеЕсли Символ = "/" И Поз + 1 <= СтрДлина(Строка) И Сред(Строка, Поз + 1, 1) = "/" Тогда
			// Комментарий - остаток строки игнорируем
			Прервать;
		КонецЕсли;
		
		Поз = Поз + 1;
	КонецЦикла;
	
	Возврат ВСтроке;
	
КонецФункции

// Проверяет, является ли строка продолжением многострочного строкового литерала.
// В BSL такие строки начинаются с символа | (после опциональных пробелов/табуляции).
Функция ЭтоПродолжениеМногострочнойСтроки(Знач Строка)
	
	Обрезанная = СокрЛ(Строка);
	Возврат СтрНачинаетсяС(Обрезанная, "|");
	
КонецФункции

// Анализирует строку и возвращает её состояние для маркировки.
// Учитывает литералы и баланс скобок.
// Параметры:
//   Строка - анализируемая строка кода
//   НачВнутриЛитерала - находимся ли в начале внутри незакрытого литерала
//   НачБалансСкобок - баланс скобок на начало строки
// Возвращает:
//   Структура с полями:
//     ВнутриЛитерала - находимся ли в конце внутри литерала
//     БалансСкобок - баланс скобок в конце
//     МожноДобавитьМаркер - можно ли безопасно добавить маркер (не внутри литерала и скобки закрыты)
Функция АнализСостоянияСтроки(Знач Строка, Знач НачВнутриЛитерала = Ложь, Знач НачБалансСкобок = 0)
	
	ВЛитерале = НачВнутриЛитерала;
	ВДате = Ложь;
	Баланс = НачБалансСкобок;
	Поз = 1;
	
	Пока Поз <= СтрДлина(Строка) Цикл
		Символ = Сред(Строка, Поз, 1);
		
		Если ВЛитерале Тогда
			Если Символ = """" Тогда
				// Проверяем экранированную кавычку ""
				Если Поз + 1 <= СтрДлина(Строка) И Сред(Строка, Поз + 1, 1) = """" Тогда
					Поз = Поз + 1; // Пропускаем вторую кавычку
				Иначе
					ВЛитерале = Ложь; // Строка закрыта
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ВДате Тогда
			Если Символ = "'" Тогда
				ВДате = Ложь;
			КонецЕсли;
		ИначеЕсли Символ = """" Тогда
			ВЛитерале = Истина;
		ИначеЕсли Символ = "'" Тогда
			ВДате = Истина;
		ИначеЕсли Символ = "/" И Поз + 1 <= СтрДлина(Строка) И Сред(Строка, Поз + 1, 1) = "/" Тогда
			// Комментарий - остаток строки игнорируем
			Прервать;
		ИначеЕсли Символ = "(" Тогда
			Баланс = Баланс + 1;
		ИначеЕсли Символ = ")" Тогда
			Баланс = Баланс - 1;
		ИначеЕсли Символ = "[" Тогда
			Баланс = Баланс + 1;
		ИначеЕсли Символ = "]" Тогда
			Баланс = Баланс - 1;
		КонецЕсли;
		
		Поз = Поз + 1;
	КонецЦикла;
	
	// Маркер можно добавить только если не внутри литерала и все скобки закрыты
	МожноМаркер = Не ВЛитерале И Баланс <= 0;
	
	Возврат Новый Структура("ВнутриЛитерала, БалансСкобок, МожноДобавитьМаркер", ВЛитерале, Баланс, МожноМаркер);
	
КонецФункции

// Заменяет одиночный Возврат X; на resultVar = X;
// Учитывает многострочные выражения (незакрытые скобки).
Функция ЗаменитьПростойВозврат(Знач Тело, Знач ПеремРезультата)
	
	Строки = СтрРазделить(Тело, Символы.ПС);
	Результат = Новый Массив;
	
	СобираемВозврат = Ложь; // Находимся в процессе сборки многострочного Возврат
	СтрокиВозврата = Новый Массив; // Строки многострочного возврата
	ОтступВозврата = "";
	МаркерВозврата = "";
	БалансСкобок = 0;
	ВнутриЛитерала = Ложь;
	
	Для Инд = 0 По Строки.ВГраница() Цикл
		Строка = Строки[Инд];
		Обрезанная = СокрЛП(Строка);
		
		// Пропускаем комментарии (но не внутри многострочного возврата)
		Если Не СобираемВозврат И СтрНачинаетсяС(Обрезанная, "//") Тогда
			Результат.Добавить(Строка);
			Продолжить;
		КонецЕсли;
		
		Если СобираемВозврат Тогда
			// Продолжаем сбор многострочного возврата
			СтрокиВозврата.Добавить(Строка);
			
			// Анализируем состояние
			Анализ = АнализСостоянияСтроки(Строка, ВнутриЛитерала, Макс(БалансСкобок, 0));
			ВнутриЛитерала = Анализ.ВнутриЛитерала;
			БалансСкобок = Анализ.БалансСкобок;
			
			// Если все скобки закрыты и литерал закрыт - выражение завершено
			Если Анализ.МожноДобавитьМаркер Тогда
				// Первая строка - с Возврат, остальные - продолжение
				ПерваяСтрока = СтрокиВозврата[0];
				РезМаркераПервой = ИзвлечьМаркер(ПерваяСтрока);
				ОбрПерваяБезМаркера = СокрЛП(РезМаркераПервой.ТекстБезМаркера);
				РезВозврат = РаспознатьВозврат(ОбрПерваяБезМаркера);
				
				// Первая строка: resultVar = выражение
				Результат.Добавить(ОтступВозврата + ПеремРезультата + " = " + РезВозврат.Выражение);
				
				// Добавляем промежуточные строки (от 1 до предпоследней)
				Для Сч = 1 По СтрокиВозврата.ВГраница() - 1 Цикл
					Результат.Добавить(СтрокиВозврата[Сч]);
				КонецЦикла;
				
				// Последняя строка 
				Если СтрокиВозврата.Количество() > 1 Тогда
					// Многострочный: добавляем последнюю строку с маркером
					ПоследняяСтрока = СтрокиВозврата[СтрокиВозврата.ВГраница()];
					РезМаркераПосл = ИзвлечьМаркер(ПоследняяСтрока);
					РезПослБезМаркера = СокрП(РезМаркераПосл.ТекстБезМаркера);
					// Убираем ; если уже есть в конце
					Если СтрЗаканчиваетсяНа(РезПослБезМаркера, ";") Тогда
						РезПослБезМаркера = Лев(РезПослБезМаркера, СтрДлина(РезПослБезМаркера) - 1);
					КонецЕсли;
					// Добавляем последнюю строку (не перезаписываем!)
					Результат.Добавить(РезПослБезМаркера + ";" + МаркерВозврата);
				Иначе
					// Однострочный возврат - корректируем последнюю добавленную
					ПоследняяСтрока = Результат[Результат.ВГраница()];
					РезМаркераПосл = ИзвлечьМаркер(ПоследняяСтрока);
					РезПослБезМаркера = СокрП(РезМаркераПосл.ТекстБезМаркера);
					Если СтрЗаканчиваетсяНа(РезПослБезМаркера, ";") Тогда
						РезПослБезМаркера = Лев(РезПослБезМаркера, СтрДлина(РезПослБезМаркера) - 1);
					КонецЕсли;
					Результат[Результат.ВГраница()] = РезПослБезМаркера + ";" + МаркерВозврата;
				КонецЕсли;
				
				СобираемВозврат = Ложь;
				СтрокиВозврата = Новый Массив;
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		
		// Извлекаем маркер //@@N
		РезМаркера = ИзвлечьМаркер(Строка);
		СтрокаБезМаркера = РезМаркера.ТекстБезМаркера;
		Маркер = РезМаркера.Маркер;
		
		ОбрБезМаркера = СокрЛП(СтрокаБезМаркера);
		
		// Проверяем Возврат
		РезВозврат = РаспознатьВозврат(ОбрБезМаркера);
		Если РезВозврат <> Неопределено Тогда
			ОтступВозврата = ПолучитьОтступ(Строка);
			МаркерВозврата = Маркер;
			
			Выражение = РезВозврат.Выражение;
			Если Не ЗначениеЗаполнено(Выражение) Тогда
				Выражение = "Неопределено";
			КонецЕсли;
			
			// Анализируем, завершено ли выражение на этой строке
			Анализ = АнализСостоянияСтроки(Выражение, Ложь, 0);
			
			Если Анализ.МожноДобавитьМаркер Тогда
				// Простой однострочный возврат
				Результат.Добавить(ОтступВозврата + ПеремРезультата + " = " + Выражение + ";" + Маркер);
			Иначе
				// Многострочный возврат - начинаем сборку
				СобираемВозврат = Истина;
				СтрокиВозврата.Добавить(Строка);
				ВнутриЛитерала = Анализ.ВнутриЛитерала;
				БалансСкобок = Анализ.БалансСкобок;
			КонецЕсли;
		Иначе
			Результат.Добавить(Строка);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрСоединить(Результат, Символы.ПС);
	
КонецФункции

// Обрабатывает множественные Возврат через флаг завершения.
Функция ЗаменитьМножественныеВозвраты(Знач Тело, Знач ПеремРезультата, Знач Суффикс)
	
	ФлагЗавершения = "_з" + Формат(Суффикс, "ЧГ=");
	Строки = СтрРазделить(Тело, Символы.ПС);
	
	Результат = Новый Массив;
	Результат.Добавить(ПеремРезультата + " = Неопределено;");
	Результат.Добавить(ФлагЗавершения + " = Ложь;");
	
	// Сначала соберём многострочные Возвраты в одну строку
	СтрокиНорм = Новый Массив;
	СобираемВозврат = Ложь;
	БуферВозврата = "";
	ВнутриЛитерала = Ложь;
	БалансСкобок = 0;
	
	Для Инд = 0 По Строки.ВГраница() Цикл
		Строка = Строки[Инд];
		Обрезанная = СокрЛП(Строка);
		
		Если СобираемВозврат Тогда
			БуферВозврата = БуферВозврата + " " + СокрЛП(Строка);
			
			Анализ = АнализСостоянияСтроки(Строка, ВнутриЛитерала, Макс(БалансСкобок, 0));
			ВнутриЛитерала = Анализ.ВнутриЛитерала;
			БалансСкобок = Анализ.БалансСкобок;
			
			Если Анализ.МожноДобавитьМаркер Тогда
				СтрокиНорм.Добавить(БуферВозврата);
				СобираемВозврат = Ложь;
				БуферВозврата = "";
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		
		Если Не СтрНачинаетсяС(Обрезанная, "//") Тогда
			РезМаркера = ИзвлечьМаркер(Строка);
			ОбрБезМаркера = СокрЛП(РезМаркера.ТекстБезМаркера);
			РезВозврат = РаспознатьВозврат(ОбрБезМаркера);
			
			Если РезВозврат <> Неопределено Тогда
				Выражение = РезВозврат.Выражение;
				Если ЗначениеЗаполнено(Выражение) Тогда
					Анализ = АнализСостоянияСтроки(Выражение, Ложь, 0);
				Иначе
					Анализ = Новый Структура("МожноДобавитьМаркер, ВнутриЛитерала, БалансСкобок", Истина, Ложь, 0);
				КонецЕсли;
				
				Если Анализ.МожноДобавитьМаркер Тогда
					СтрокиНорм.Добавить(Строка);
				Иначе
					СобираемВозврат = Истина;
					БуферВозврата = Строка;
					ВнутриЛитерала = Анализ.ВнутриЛитерала;
					БалансСкобок = Анализ.БалансСкобок;
				КонецЕсли;
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		СтрокиНорм.Добавить(Строка);
	КонецЦикла;
	
	Если СобираемВозврат Тогда
		СтрокиНорм.Добавить(БуферВозврата);
	КонецЕсли;
	
	// Стек для отслеживания необходимости обёртки на каждом уровне вложенности
	// Ключ = уровень глубины, Значение = нужно ли оборачивать следующие операторы
	ГлубинаПослеВозврата = Новый Соответствие;
	ТекГлубина = 0;
	БылВозвратНаУровне = Новый Соответствие; // Был ли Возврат на данном уровне или выше
	ГлубинаЦикла = 0; // Счётчик вложенности в циклы
	
	Для Каждого Строка Из СтрокиНорм Цикл
		Обрезанная = СокрЛП(Строка);
		Отступ = ПолучитьОтступ(Строка);
		
		Если Не ЗначениеЗаполнено(Обрезанная) Тогда
			Результат.Добавить(Строка);
			Продолжить;
		КонецЕсли;
		
		// Проверяем закрывающие конструкции
		Если Не СтрНачинаетсяС(Обрезанная, "//") Тогда
			
			// Промежуточные ключевые слова (Исключение, Иначе, ИначеЕсли) - 
			// закрываем обёртку перед ними, выводим как есть, сбрасываем флаг
			Если ЭтоПромежуточноеКлючевоеСлово(Обрезанная) Тогда
				// Закрываем обёртку на текущем уровне если была
				Если ГлубинаПослеВозврата.Получить(ТекГлубина) = Истина Тогда
					Результат.Добавить(Отступ + "КонецЕсли;");
					ГлубинаПослеВозврата.Удалить(ТекГлубина);
				КонецЕсли;
				// Сбрасываем флаг "был возврат" - после Исключение/Иначе начинаем заново
				БылВозвратНаУровне.Удалить(ТекГлубина);
				Результат.Добавить(Строка);
				Продолжить;
			КонецЕсли;
			
			ДельтаДо = ПолучитьДельтуВложенностиДо(Обрезанная);
			
			// Если это КонецЕсли/КонецЦикла/etc - сначала закрываем уровень
			Если ДельтаДо < 0 Тогда
				// Уменьшаем счётчик циклов при КонецЦикла
				Если ЭтоКонецЦикла(Обрезанная) Тогда
					ГлубинаЦикла = ГлубинаЦикла - 1;
				КонецЕсли;
				// Закрываем проверку флага на этом уровне если была
				Если ГлубинаПослеВозврата.Получить(ТекГлубина) = Истина Тогда
					Результат.Добавить(Отступ + "КонецЕсли;");
					ГлубинаПослеВозврата.Удалить(ТекГлубина);
				КонецЕсли;
				
				// Пробрасываем флаг "был возврат" на уровень выше при выходе из блока
				Если БылВозвратНаУровне.Получить(ТекГлубина) = Истина Тогда
					БылВозвратНаУровне.Удалить(ТекГлубина);
					НовыйУровень = ТекГлубина + ДельтаДо;
					Если НовыйУровень >= 0 Тогда
						БылВозвратНаУровне.Вставить(НовыйУровень, Истина);
					КонецЕсли;
				КонецЕсли;
				
				ТекГлубина = ТекГлубина + ДельтаДо;
				
				// Выводим закрывающую конструкцию и переходим к следующей строке
				// (нельзя оборачивать закрывающие конструкции)
				Результат.Добавить(Строка);
				Продолжить;
			КонецЕсли;
			
			РезМаркера = ИзвлечьМаркер(Строка);
			Маркер = РезМаркера.Маркер;
			ОбрБезМаркера = СокрЛП(РезМаркера.ТекстБезМаркера);
			
			// Проверяем открывающие конструкции (нужно знать до обёртки)
			ДельтаПосле = ПолучитьДельтуВложенностиПосле(Обрезанная);
			
			// Если был возврат на текущем уровне - оборачиваем следующий оператор
			// (ВАЖНО: делаем ДО проверки на Возврат, т.к. Возврат тоже нужно обернуть)
			Если БылВозвратНаУровне.Получить(ТекГлубина) = Истина Тогда
				// Начинаем обёртку только если она ещё не открыта на этом уровне
				Если ГлубинаПослеВозврата.Получить(ТекГлубина) <> Истина Тогда
					Результат.Добавить(Отступ + "Если Не " + ФлагЗавершения + " Тогда");
					ГлубинаПослеВозврата.Вставить(ТекГлубина, Истина);
				КонецЕсли;
				БылВозвратНаУровне.Удалить(ТекГлубина);
			КонецЕсли;
			
			РезВозврат = РаспознатьВозврат(ОбрБезМаркера);
			Если РезВозврат <> Неопределено Тогда
				Выражение = РезВозврат.Выражение;
				Если Не ЗначениеЗаполнено(Выражение) Тогда
					Выражение = "Неопределено";
				КонецЕсли;
				Результат.Добавить(Отступ + ПеремРезультата + " = " + Выражение + ";" + Маркер);
				Результат.Добавить(Отступ + ФлагЗавершения + " = Истина;" + Маркер);
				// Если внутри цикла - добавляем Прервать для выхода из цикла
				Если ГлубинаЦикла > 0 Тогда
					Результат.Добавить(Отступ + "Прервать;" + Маркер);
				КонецЕсли;
				// Помечаем что на этом уровне был возврат - следующий оператор нужно обернуть
				БылВозвратНаУровне.Вставить(ТекГлубина, Истина);
				Продолжить;
			КонецЕсли;
			
			Результат.Добавить(Строка);
			
			// Увеличиваем счётчик циклов при входе в цикл
			Если ЭтоОткрытиеЦикла(Обрезанная) Тогда
				ГлубинаЦикла = ГлубинаЦикла + 1;
			КонецЕсли;
			
			Если ДельтаПосле > 0 Тогда
				ТекГлубина = ТекГлубина + ДельтаПосле;
			КонецЕсли;
		Иначе
			Результат.Добавить(Строка);
		КонецЕсли;
	КонецЦикла;
	
	// Закрываем все оставшиеся обёртки
	Для Глубина = ТекГлубина По 0 Цикл
		Если ГлубинаПослеВозврата.Получить(Глубина) = Истина Тогда
			Результат.Добавить("КонецЕсли;");
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрСоединить(Результат, Символы.ПС);
	
КонецФункции

// Проверяет, является ли строка промежуточным ключевым словом блока
// (Исключение, Иначе, ИначеЕсли) - их нельзя оборачивать в Если
Функция ЭтоПромежуточноеКлючевоеСлово(Знач Обрезанная)
	
	ОбрВРег = ВРег(Обрезанная);
	
	Если СтрНачинаетсяС(ОбрВРег, "ИСКЛЮЧЕНИЕ")
		Или СтрНачинаетсяС(ОбрВРег, "EXCEPT") Тогда
		Возврат Истина;
	ИначеЕсли СтрНачинаетсяС(ОбрВРег, "ИНАЧЕЕСЛИ ")
		Или СтрНачинаетсяС(ОбрВРег, "ELSIF ") Тогда
		Возврат Истина;
	ИначеЕсли СтрНачинаетсяС(ОбрВРег, "ИНАЧЕ")
		Или СтрНачинаетсяС(ОбрВРег, "ELSE") Тогда
		// Проверяем что это не ИначеЕсли
		Если Не СтрНачинаетсяС(ОбрВРег, "ИНАЧЕЕСЛИ") Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет, является ли строка открытием цикла (Для...Цикл или Пока...Цикл)
Функция ЭтоОткрытиеЦикла(Знач Обрезанная)
	
	ОбрВРег = ВРег(Обрезанная);
	
	// Убираем комментарий в конце строки
	ПозКоммент = СтрНайти(ОбрВРег, "//");
	Если ПозКоммент > 0 Тогда
		ОбрВРег = СокрП(Лев(ОбрВРег, ПозКоммент - 1));
	КонецЕсли;
	
	// Для ... Цикл / For ... Do
	Если СтрНачинаетсяС(ОбрВРег, "ДЛЯ ")
		Или СтрНачинаетсяС(ОбрВРег, "FOR ") Тогда
		Возврат СтрЗаканчиваетсяНа(ОбрВРег, " ЦИКЛ")
			Или СтрЗаканчиваетсяНа(ОбрВРег, " DO");
	КонецЕсли;
	
	// Пока ... Цикл / While ... Do
	Если СтрНачинаетсяС(ОбрВРег, "ПОКА ")
		Или СтрНачинаетсяС(ОбрВРег, "WHILE ") Тогда
		Возврат СтрЗаканчиваетсяНа(ОбрВРег, " ЦИКЛ")
			Или СтрЗаканчиваетсяНа(ОбрВРег, " DO");
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет, является ли строка закрытием цикла (КонецЦикла / EndDo)
Функция ЭтоКонецЦикла(Знач Обрезанная)
	
	ОбрВРег = ВРег(Обрезанная);
	
	Возврат СтрНачинаетсяС(ОбрВРег, "КОНЕЦЦИКЛА")
		Или СтрНачинаетсяС(ОбрВРег, "ENDDO");
	
КонецФункции

// Получает дельту вложенности ДО обработки строки (для закрывающих конструкций)
Функция ПолучитьДельтуВложенностиДо(Знач Обрезанная)
	
	ОбрВРег = ВРег(Обрезанная);
	
	Если СтрНачинаетсяС(ОбрВРег, "КОНЕЦЕСЛИ")
		Или СтрНачинаетсяС(ОбрВРег, "ENDIF") Тогда
		Возврат -1;
	ИначеЕсли СтрНачинаетсяС(ОбрВРег, "КОНЕЦЦИКЛА")
		Или СтрНачинаетсяС(ОбрВРег, "ENDDO") Тогда
		Возврат -1;
	ИначеЕсли СтрНачинаетсяС(ОбрВРег, "КОНЕЦПОПЫТКИ")
		Или СтрНачинаетсяС(ОбрВРег, "ENDTRY") Тогда
		Возврат -1;
	ИначеЕсли СтрНачинаетсяС(ОбрВРег, "ИСКЛЮЧЕНИЕ")
		Или СтрНачинаетсяС(ОбрВРег, "EXCEPT") Тогда
		Возврат 0; // Исключение не меняет глубину
	ИначеЕсли СтрНачинаетсяС(ОбрВРег, "ИНАЧЕ")
		Или СтрНачинаетсяС(ОбрВРег, "ELSE") Тогда
		Возврат 0; // Иначе не меняет глубину, но может потребовать закрытия
	ИначеЕсли СтрНачинаетсяС(ОбрВРег, "ИНАЧЕЕСЛИ")
		Или СтрНачинаетсяС(ОбрВРег, "ELSIF") Тогда
		Возврат 0;
	КонецЕсли;
	
	Возврат 0;
	
КонецФункции

// Получает дельту вложенности ПОСЛЕ обработки строки (для открывающих конструкций)
Функция ПолучитьДельтуВложенностиПосле(Знач Обрезанная)
	
	ОбрВРег = ВРег(Обрезанная);
	
	Если СтрНачинаетсяС(ОбрВРег, "ЕСЛИ ") Или СтрНачинаетсяС(ОбрВРег, "IF ") Тогда
		Если СтрНайти(ОбрВРег, "ТОГДА") > 0 Или СтрНайти(ОбрВРег, "THEN") > 0 Тогда
			Возврат 1;
		КонецЕсли;
	ИначеЕсли СтрНачинаетсяС(ОбрВРег, "ДЛЯ ") Или СтрНачинаетсяС(ОбрВРег, "FOR ") Тогда
		Если СтрНайти(ОбрВРег, "ЦИКЛ") > 0 Или СтрНайти(ОбрВРег, "DO") > 0 Тогда
			Возврат 1;
		КонецЕсли;
	ИначеЕсли СтрНачинаетсяС(ОбрВРег, "ПОКА ") Или СтрНачинаетсяС(ОбрВРег, "WHILE ") Тогда
		Если СтрНайти(ОбрВРег, "ЦИКЛ") > 0 Или СтрНайти(ОбрВРег, "DO") > 0 Тогда
			Возврат 1;
		КонецЕсли;
	ИначеЕсли СтрНачинаетсяС(ОбрВРег, "ПОПЫТКА") Или СтрНачинаетсяС(ОбрВРег, "TRY") Тогда
		Возврат 1;
	ИначеЕсли СтрНачинаетсяС(ОбрВРег, "ИНАЧЕЕСЛИ ") Или СтрНачинаетсяС(ОбрВРег, "ELSIF ") Тогда
		Если СтрНайти(ОбрВРег, "ТОГДА") > 0 Или СтрНайти(ОбрВРег, "THEN") > 0 Тогда
			Возврат 0; // Не увеличиваем, уже внутри Если
		КонецЕсли;
	КонецЕсли;
	
	Возврат 0;
	
КонецФункции

// Распознаёт инструкцию Возврат.
Функция РаспознатьВозврат(Знач Обрезанная)
	
	Если НачинаетсяСКлючевогоСлова(Обрезанная, "Возврат") Тогда
		Остаток = СокрЛП(Сред(Обрезанная, 8));
		Остаток = СокрП(СтрЗаменить(Остаток, ";", ""));
		Возврат Новый Структура("Выражение", СокрЛП(Остаток));
	ИначеЕсли НачинаетсяСКлючевогоСлова(Обрезанная, "Return") Тогда
		Остаток = СокрЛП(Сред(Обрезанная, 7));
		Остаток = СокрП(СтрЗаменить(Остаток, ";", ""));
		Возврат Новый Структура("Выражение", СокрЛП(Остаток));
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

#КонецОбласти

#Область Утилиты

// Разбивает строку аргументов вызова, учитывая вложенные скобки и строки.
Функция РазделитьАргументы(Знач СтрАрг)
	
	Если Не ЗначениеЗаполнено(СокрЛП(СтрАрг)) Тогда
		Возврат Новый Массив;
	КонецЕсли;
	
	Возврат РазделитьНаВерхнемУровне(СтрАрг, ",");
	
КонецФункции

// Разбивает строку по разделителю на верхнем уровне.
Функция РазделитьНаВерхнемУровне(Знач Строка, Знач Разделитель)
	
	Части = Новый Массив;
	Текущий = "";
	Глубина = 0;
	ВСтроке = Ложь;
	ВДате = Ложь;
	
	Для Поз = 1 По СтрДлина(Строка) Цикл
		Символ = Сред(Строка, Поз, 1);
		
		Если ВСтроке Тогда
			Текущий = Текущий + Символ;
			Если Символ = """" Тогда
				Если Поз + 1 <= СтрДлина(Строка) И Сред(Строка, Поз + 1, 1) = """" Тогда
					// Пропустим — обработается на следующей итерации как часть строки
				Иначе
					ВСтроке = Ложь;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ВДате Тогда
			Текущий = Текущий + Символ;
			Если Символ = "'" Тогда
				ВДате = Ложь;
			КонецЕсли;
		ИначеЕсли Символ = """" Тогда
			ВСтроке = Истина;
			Текущий = Текущий + Символ;
		ИначеЕсли Символ = "'" Тогда
			ВДате = Истина;
			Текущий = Текущий + Символ;
		ИначеЕсли Символ = "(" Тогда
			Глубина = Глубина + 1;
			Текущий = Текущий + Символ;
		ИначеЕсли Символ = ")" Тогда
			Глубина = Глубина - 1;
			Текущий = Текущий + Символ;
		ИначеЕсли Символ = Разделитель И Глубина = 0 Тогда
			Части.Добавить(СокрЛП(Текущий));
			Текущий = "";
		Иначе
			Текущий = Текущий + Символ;
		КонецЕсли;
	КонецЦикла;
	
	Если ЗначениеЗаполнено(СокрЛП(Текущий)) Тогда
		Части.Добавить(СокрЛП(Текущий));
	КонецЕсли;
	
	Возврат Части;
	
КонецФункции

// Находит позицию закрывающей скобки, соответствующей открывающей.
// Позиция 1-based. Возвращает 0 если не найдена.
Функция НайтиПарнуюСкобку(Знач Строка, Знач ПозОткрывающей)
	
	Глубина = 0;
	ВСтроке = Ложь;
	ВДате = Ложь;
	
	Для Поз = ПозОткрывающей По СтрДлина(Строка) Цикл
		Символ = Сред(Строка, Поз, 1);
		
		Если ВСтроке Тогда
			Если Символ = """" Тогда
				Если Поз + 1 <= СтрДлина(Строка) И Сред(Строка, Поз + 1, 1) = """" Тогда
					// Экранированная кавычка — пропускаем
				Иначе
					ВСтроке = Ложь;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ВДате Тогда
			Если Символ = "'" Тогда
				ВДате = Ложь;
			КонецЕсли;
		ИначеЕсли Символ = """" Тогда
			ВСтроке = Истина;
		ИначеЕсли Символ = "'" Тогда
			ВДате = Истина;
		ИначеЕсли Символ = "(" Тогда
			Глубина = Глубина + 1;
		ИначеЕсли Символ = ")" Тогда
			Глубина = Глубина - 1;
			Если Глубина = 0 Тогда
				Возврат Поз;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат 0;
	
КонецФункции

// Разбивает строку кода на сегменты: код, строки, комментарии, даты.
Функция РазбитьСтрокуНаСегменты(Знач Строка)
	
	Сегменты = Новый Массив;
	Поз = 1;
	ТекущийКод = "";
	
	Пока Поз <= СтрДлина(Строка) Цикл
		Символ = Сред(Строка, Поз, 1);
		
		// Комментарий
		Если Символ = "/" И Поз + 1 <= СтрДлина(Строка) И Сред(Строка, Поз + 1, 1) = "/" Тогда
			Если ЗначениеЗаполнено(ТекущийКод) Тогда
				Сегменты.Добавить(Новый Структура("Тип, Текст", "код", ТекущийКод));
				ТекущийКод = "";
			КонецЕсли;
			Сегменты.Добавить(Новый Структура("Тип, Текст", "комментарий", Сред(Строка, Поз)));
			Возврат Сегменты;
		КонецЕсли;
		
		// Строковый литерал
		Если Символ = """" Тогда
			Если ЗначениеЗаполнено(ТекущийКод) Тогда
				Сегменты.Добавить(Новый Структура("Тип, Текст", "код", ТекущийКод));
				ТекущийКод = "";
			КонецЕсли;
			СтрЛитерал = """";
			Поз = Поз + 1;
			Пока Поз <= СтрДлина(Строка) Цикл
				СимвТек = Сред(Строка, Поз, 1);
				Если СимвТек = """" Тогда
					СтрЛитерал = СтрЛитерал + """";
					Поз = Поз + 1;
					Если Поз <= СтрДлина(Строка) И Сред(Строка, Поз, 1) = """" Тогда
						СтрЛитерал = СтрЛитерал + """";
						Поз = Поз + 1;
					Иначе
						Прервать;
					КонецЕсли;
				Иначе
					СтрЛитерал = СтрЛитерал + СимвТек;
					Поз = Поз + 1;
				КонецЕсли;
			КонецЦикла;
			Сегменты.Добавить(Новый Структура("Тип, Текст", "строка", СтрЛитерал));
			Продолжить;
		КонецЕсли;
		
		// Дата-литерал
		Если Символ = "'" Тогда
			Если ЗначениеЗаполнено(ТекущийКод) Тогда
				Сегменты.Добавить(Новый Структура("Тип, Текст", "код", ТекущийКод));
				ТекущийКод = "";
			КонецЕсли;
			ДатаЛитерал = "'";
			Поз = Поз + 1;
			Пока Поз <= СтрДлина(Строка) И Сред(Строка, Поз, 1) <> "'" Цикл
				ДатаЛитерал = ДатаЛитерал + Сред(Строка, Поз, 1);
				Поз = Поз + 1;
			КонецЦикла;
			Если Поз <= СтрДлина(Строка) Тогда
				ДатаЛитерал = ДатаЛитерал + "'";
				Поз = Поз + 1;
			КонецЕсли;
			Сегменты.Добавить(Новый Структура("Тип, Текст", "дата", ДатаЛитерал));
			Продолжить;
		КонецЕсли;
		
		ТекущийКод = ТекущийКод + Символ;
		Поз = Поз + 1;
	КонецЦикла;
	
	Если ЗначениеЗаполнено(ТекущийКод) Тогда
		Сегменты.Добавить(Новый Структура("Тип, Текст", "код", ТекущийКод));
	КонецЕсли;
	
	Возврат Сегменты;
	
КонецФункции

// Разбивает строку кода на сегменты с учётом контекста многострочных литералов.
// Параметры:
//   Строка - текущая строка
//   ВнутриСтроки - находимся ли в начале строки внутри незакрытого строкового литерала
// Возврат:
//   Структура с полями Сегменты и ВнутриСтроки (состояние на конец строки)
Функция РазбитьСтрокуНаСегментыСКонтекстом(Знач Строка, Знач ВнутриСтроки)
	
	Сегменты = Новый Массив;
	Поз = 1;
	ТекущийКод = "";
	ТекущаяСтрока = "";
	
	// Если мы внутри многострочного литерала, ищем его закрытие
	Если ВнутриСтроки Тогда
		// Строка-продолжение начинается с | (после пробелов)
		// Всё до закрывающей кавычки - часть строкового литерала
		Пока Поз <= СтрДлина(Строка) Цикл
			СимвТек = Сред(Строка, Поз, 1);
			Если СимвТек = """" Тогда
				ТекущаяСтрока = ТекущаяСтрока + """";
				Поз = Поз + 1;
				// Проверяем экранированную кавычку ""
				Если Поз <= СтрДлина(Строка) И Сред(Строка, Поз, 1) = """" Тогда
					ТекущаяСтрока = ТекущаяСтрока + """";
					Поз = Поз + 1;
				Иначе
					// Строковый литерал закрыт
					Сегменты.Добавить(Новый Структура("Тип, Текст", "строка", ТекущаяСтрока));
					ТекущаяСтрока = "";
					ВнутриСтроки = Ложь;
					Прервать;
				КонецЕсли;
			Иначе
				ТекущаяСтрока = ТекущаяСтрока + СимвТек;
				Поз = Поз + 1;
			КонецЕсли;
		КонецЦикла;
		
		// Если строка не была закрыта
		Если ВнутриСтроки Тогда
			Сегменты.Добавить(Новый Структура("Тип, Текст", "строка", ТекущаяСтрока));
			Возврат Новый Структура("Сегменты, ВнутриСтроки", Сегменты, Истина);
		КонецЕсли;
	КонецЕсли;
	
	// Обрабатываем остаток строки как обычно
	Пока Поз <= СтрДлина(Строка) Цикл
		Символ = Сред(Строка, Поз, 1);
		
		// Комментарий
		Если Символ = "/" И Поз + 1 <= СтрДлина(Строка) И Сред(Строка, Поз + 1, 1) = "/" Тогда
			Если ЗначениеЗаполнено(ТекущийКод) Тогда
				Сегменты.Добавить(Новый Структура("Тип, Текст", "код", ТекущийКод));
				ТекущийКод = "";
			КонецЕсли;
			Сегменты.Добавить(Новый Структура("Тип, Текст", "комментарий", Сред(Строка, Поз)));
			Возврат Новый Структура("Сегменты, ВнутриСтроки", Сегменты, Ложь);
		КонецЕсли;
		
		// Строковый литерал
		Если Символ = """" Тогда
			Если ЗначениеЗаполнено(ТекущийКод) Тогда
				Сегменты.Добавить(Новый Структура("Тип, Текст", "код", ТекущийКод));
				ТекущийКод = "";
			КонецЕсли;
			СтрЛитерал = """";
			Поз = Поз + 1;
			СтрокаЗакрыта = Ложь;
			Пока Поз <= СтрДлина(Строка) Цикл
				СимвТек = Сред(Строка, Поз, 1);
				Если СимвТек = """" Тогда
					СтрЛитерал = СтрЛитерал + """";
					Поз = Поз + 1;
					Если Поз <= СтрДлина(Строка) И Сред(Строка, Поз, 1) = """" Тогда
						СтрЛитерал = СтрЛитерал + """";
						Поз = Поз + 1;
					Иначе
						СтрокаЗакрыта = Истина;
						Прервать;
					КонецЕсли;
				Иначе
					СтрЛитерал = СтрЛитерал + СимвТек;
					Поз = Поз + 1;
				КонецЕсли;
			КонецЦикла;
			Сегменты.Добавить(Новый Структура("Тип, Текст", "строка", СтрЛитерал));
			Если Не СтрокаЗакрыта Тогда
				// Многострочная строка - продолжится на следующей строке
				Возврат Новый Структура("Сегменты, ВнутриСтроки", Сегменты, Истина);
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		
		// Дата-литерал
		Если Символ = "'" Тогда
			Если ЗначениеЗаполнено(ТекущийКод) Тогда
				Сегменты.Добавить(Новый Структура("Тип, Текст", "код", ТекущийКод));
				ТекущийКод = "";
			КонецЕсли;
			ДатаЛитерал = "'";
			Поз = Поз + 1;
			Пока Поз <= СтрДлина(Строка) И Сред(Строка, Поз, 1) <> "'" Цикл
				ДатаЛитерал = ДатаЛитерал + Сред(Строка, Поз, 1);
				Поз = Поз + 1;
			КонецЦикла;
			Если Поз <= СтрДлина(Строка) Тогда
				ДатаЛитерал = ДатаЛитерал + "'";
				Поз = Поз + 1;
			КонецЕсли;
			Сегменты.Добавить(Новый Структура("Тип, Текст", "дата", ДатаЛитерал));
			Продолжить;
		КонецЕсли;
		
		ТекущийКод = ТекущийКод + Символ;
		Поз = Поз + 1;
	КонецЦикла;
	
	Если ЗначениеЗаполнено(ТекущийКод) Тогда
		Сегменты.Добавить(Новый Структура("Тип, Текст", "код", ТекущийКод));
	КонецЕсли;
	
	Возврат Новый Структура("Сегменты, ВнутриСтроки", Сегменты, Ложь);
	
КонецФункции

// Вычисляет изменение уровня вложенности для строки.
Функция ПолучитьДельтуВложенности(Знач Обрезанная)
	
	Если СтрНачинаетсяС(Обрезанная, "//") Тогда
		Возврат 0;
	КонецЕсли;
	
	// Удаляем строковые литералы
	Очищенная = УдалитьСтроковыеЛитералы(Обрезанная);
	ВРег = ВРег(Очищенная);
	
	Дельта = 0;
	
	// Открывающие конструкции
	Если СодержитКлючевоеВыражение(ВРег, "ЕСЛИ", "ТОГДА")
		Или СодержитКлючевоеВыражение(ВРег, "IF", "THEN") Тогда
		Дельта = Дельта + 1;
	КонецЕсли;
	
	Если СодержитКлючевоеВыражение(ВРег, "ДЛЯ", "ЦИКЛ")
		Или СодержитКлючевоеВыражение(ВРег, "FOR", "DO") Тогда
		Дельта = Дельта + 1;
	КонецЕсли;
	
	Если СодержитКлючевоеВыражение(ВРег, "ПОКА", "ЦИКЛ")
		Или СодержитКлючевоеВыражение(ВРег, "WHILE", "DO") Тогда
		Дельта = Дельта + 1;
	КонецЕсли;
	
	Если СодержитКлючевоеСлово(ВРег, "ПОПЫТКА") Или СодержитКлючевоеСлово(ВРег, "TRY") Тогда
		Дельта = Дельта + 1;
	КонецЕсли;
	
	// Закрывающие конструкции
	Если СодержитКлючевоеСлово(ВРег, "КОНЕЦЕСЛИ") Или СодержитКлючевоеСлово(ВРег, "ENDIF") Тогда
		Дельта = Дельта - 1;
	КонецЕсли;
	
	Если СодержитКлючевоеСлово(ВРег, "КОНЕЦЦИКЛА") Или СодержитКлючевоеСлово(ВРег, "ENDDO") Тогда
		Дельта = Дельта - 1;
	КонецЕсли;
	
	Если СодержитКлючевоеСлово(ВРег, "КОНЕЦПОПЫТКИ") Или СодержитКлючевоеСлово(ВРег, "ENDTRY") Тогда
		Дельта = Дельта - 1;
	КонецЕсли;
	
	Возврат Дельта;
	
КонецФункции

// Удаляет строковые литералы из строки, заменяя их пустыми.
Функция УдалитьСтроковыеЛитералы(Знач Строка)
	
	Результат = "";
	ВСтроке = Ложь;
	ВДате = Ложь;
	
	Для Поз = 1 По СтрДлина(Строка) Цикл
		Символ = Сред(Строка, Поз, 1);
		
		Если ВСтроке Тогда
			Если Символ = """" Тогда
				Если Поз + 1 <= СтрДлина(Строка) И Сред(Строка, Поз + 1, 1) = """" Тогда
					// Экранированная кавычка — пропускаем
				Иначе
					ВСтроке = Ложь;
					Результат = Результат + """""";
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ВДате Тогда
			Если Символ = "'" Тогда
				ВДате = Ложь;
				Результат = Результат + "''";
			КонецЕсли;
		ИначеЕсли Символ = """" Тогда
			ВСтроке = Истина;
		ИначеЕсли Символ = "'" Тогда
			ВДате = Истина;
		Иначе
			Результат = Результат + Символ;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Проверяет наличие ключевого слова как отдельного слова.
Функция СодержитКлючевоеСлово(Знач СтрокаВРег, Знач Слово)
	
	Поз = СтрНайти(СтрокаВРег, Слово);
	Если Поз = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Проверяем границы слова
	Если Поз > 1 Тогда
		СимволПеред = Сред(СтрокаВРег, Поз - 1, 1);
		Если ЭтоСимволИдентификатора(СимволПеред) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	ПозПосле = Поз + СтрДлина(Слово);
	Если ПозПосле <= СтрДлина(СтрокаВРег) Тогда
		СимволПосле = Сред(СтрокаВРег, ПозПосле, 1);
		Если ЭтоСимволИдентификатора(СимволПосле) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Проверяет наличие пары ключевых слов.
Функция СодержитКлючевоеВыражение(Знач СтрокаВРег, Знач Слово1, Знач Слово2)
	Возврат СодержитКлючевоеСлово(СтрокаВРег, Слово1) И СодержитКлючевоеСлово(СтрокаВРег, Слово2);
КонецФункции

// Проверяет, начинается ли строка с ключевого слова (с учётом границы слова).
Функция НачинаетсяСКлючевогоСлова(Знач Строка, Знач Слово)
	
	ВРегСтрока = ВРег(Строка);
	ВРегСлово = ВРег(Слово);
	
	Если Не СтрНачинаетсяС(ВРегСтрока, ВРегСлово) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Проверяем, что после слова не буква/цифра
	ПозПосле = СтрДлина(Слово) + 1;
	Если ПозПосле <= СтрДлина(Строка) Тогда
		СимволПосле = Сред(Строка, ПозПосле, 1);
		Если ЭтоСимволИдентификатора(СимволПосле) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Проверяет, является ли строка допустимым идентификатором BSL.
Функция ЭтоИдентификатор(Знач Строка)
	
	Если Не ЗначениеЗаполнено(Строка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Первый символ — буква или _
	Первый = Сред(Строка, 1, 1);
	Если Не ЭтоБукваИлиПодчёркивание(Первый) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Остальные — буквы, цифры, _
	Для Поз = 2 По СтрДлина(Строка) Цикл
		Если Не ЭтоСимволИдентификатора(Сред(Строка, Поз, 1)) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Проверяет, является ли символ допустимым символом идентификатора.
Функция ЭтоСимволИдентификатора(Знач Символ)
	
	Код = КодСимвола(Символ);
	
	// a-z
	Если Код >= 97 И Код <= 122 Тогда Возврат Истина; КонецЕсли;
	// A-Z
	Если Код >= 65 И Код <= 90 Тогда Возврат Истина; КонецЕсли;
	// 0-9
	Если Код >= 48 И Код <= 57 Тогда Возврат Истина; КонецЕсли;
	// _
	Если Код = 95 Тогда Возврат Истина; КонецЕсли;
	// а-я
	Если Код >= 1072 И Код <= 1103 Тогда Возврат Истина; КонецЕсли;
	// А-Я
	Если Код >= 1040 И Код <= 1071 Тогда Возврат Истина; КонецЕсли;
	// ё
	Если Код = 1105 Тогда Возврат Истина; КонецЕсли;
	// Ё
	Если Код = 1025 Тогда Возврат Истина; КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет, является ли символ буквой или подчёркиванием.
Функция ЭтоБукваИлиПодчёркивание(Знач Символ)
	
	Код = КодСимвола(Символ);
	
	// Цифры — нет
	Если Код >= 48 И Код <= 57 Тогда Возврат Ложь; КонецЕсли;
	
	Возврат ЭтоСимволИдентификатора(Символ);
	
КонецФункции

// Извлекает идентификатор в начале строки.
Функция ИзвлечьИдентификаторВНачале(Знач Строка)
	
	Если Не ЗначениеЗаполнено(Строка) Тогда
		Возврат "";
	КонецЕсли;
	
	Если Не ЭтоБукваИлиПодчёркивание(Сред(Строка, 1, 1)) Тогда
		Возврат "";
	КонецЕсли;
	
	Длина = 1;
	Пока Длина + 1 <= СтрДлина(Строка) И ЭтоСимволИдентификатора(Сред(Строка, Длина + 1, 1)) Цикл
		Длина = Длина + 1;
	КонецЦикла;
	
	Возврат Лев(Строка, Длина);
	
КонецФункции

// Получает отступ строки (пробелы/табы в начале).
Функция ПолучитьОтступ(Знач Строка)
	
	Для Поз = 1 По СтрДлина(Строка) Цикл
		Символ = Сред(Строка, Поз, 1);
		Если Символ <> " " И Символ <> Символы.Таб Тогда
			Возврат Лев(Строка, Поз - 1);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Строка; // Вся строка — пробелы
	
КонецФункции

// Проверяет наличие маркера //@@N в строке.
Функция ЕстьМаркер(Знач Строка)
	
	// Ищем //@@<цифры> в конце строки
	Поз = СтрНайти(Строка, "//@@");
	Если Поз = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Проверяем, что после //@@  идут цифры до конца строки (с возможными пробелами)
	Остаток = СокрП(Сред(Строка, Поз + 4));
	Если Не ЗначениеЗаполнено(Остаток) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Поз2 = 1 По СтрДлина(Остаток) Цикл
		Код = КодСимвола(Сред(Остаток, Поз2, 1));
		Если Код < 48 Или Код > 57 Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Извлекает маркер //@@N из строки.
// Возвращает структуру с текстом без маркера и самим маркером.
Функция ИзвлечьМаркер(Знач Строка)
	
	Маркер = "";
	ТекстБезМаркера = Строка;
	
	Поз = СтрНайти(Строка, "//@@");
	Если Поз > 0 Тогда
		Остаток = СокрП(Сред(Строка, Поз + 4));
		ВсеЦифры = ЗначениеЗаполнено(Остаток);
		Если ВсеЦифры Тогда
			Для Поз2 = 1 По СтрДлина(Остаток) Цикл
				Код = КодСимвола(Сред(Остаток, Поз2, 1));
				Если Код < 48 Или Код > 57 Тогда
					ВсеЦифры = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Если ВсеЦифры Тогда
			Маркер = " //@@" + Остаток;
			ТекстБезМаркера = СокрП(Лев(Строка, Поз - 1));
		КонецЕсли;
	КонецЕсли;
	
	Возврат Новый Структура("ТекстБезМаркера, Маркер", ТекстБезМаркера, Маркер);
	
КонецФункции

// Извлекает номер из маркера //@@N.
Функция ИзвлечьНомерИзМаркера(Знач Строка)
	
	Поз = СтрНайти(Строка, "//@@");
	Если Поз = 0 Тогда
		Возврат 0;
	КонецЕсли;
	
	Остаток = СокрП(Сред(Строка, Поз + 4));
	Если Не ЗначениеЗаполнено(Остаток) Тогда
		Возврат 0;
	КонецЕсли;
	
	// Проверяем, что все символы — цифры
	Для Поз2 = 1 По СтрДлина(Остаток) Цикл
		Код = КодСимвола(Сред(Остаток, Поз2, 1));
		Если Код < 48 Или Код > 57 Тогда
			Возврат 0;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Число(Остаток);
	
КонецФункции

// Пропускает строковый литерал, начиная с позиции кавычки.
Функция ПропуститьСтроковыйЛитерал(Знач Строка, Знач НачПозиция)
	
	Поз = НачПозиция + 1;
	Пока Поз <= СтрДлина(Строка) Цикл
		Если Сред(Строка, Поз, 1) = """" Тогда
			Если Поз + 1 <= СтрДлина(Строка) И Сред(Строка, Поз + 1, 1) = """" Тогда
				Поз = Поз + 2; // Экранированная кавычка
			Иначе
				Возврат Поз + 1; // Конец строки
			КонецЕсли;
		Иначе
			Поз = Поз + 1;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Поз;
	
КонецФункции

// Пропускает дата-литерал, начиная с позиции одинарной кавычки.
Функция ПропуститьДатуЛитерал(Знач Строка, Знач НачПозиция)
	
	Поз = НачПозиция + 1;
	Пока Поз <= СтрДлина(Строка) Цикл
		Если Сред(Строка, Поз, 1) = "'" Тогда
			Возврат Поз + 1;
		КонецЕсли;
		Поз = Поз + 1;
	КонецЦикла;
	
	Возврат Поз;
	
КонецФункции

// Аналог СтрНайти с позиции (для совместимости со старыми версиями).
Функция СтрНайтиПосле(Знач Строка, Знач Подстрока, Знач НачПозиция)
	
	Если НачПозиция > СтрДлина(Строка) Тогда
		Возврат 0;
	КонецЕсли;
	
	Остаток = Сред(Строка, НачПозиция);
	Поз = СтрНайти(Остаток, Подстрока);
	Если Поз = 0 Тогда
		Возврат 0;
	КонецЕсли;
	
	Возврат НачПозиция + Поз - 1;
	
КонецФункции

#КонецОбласти

#КонецОбласти
