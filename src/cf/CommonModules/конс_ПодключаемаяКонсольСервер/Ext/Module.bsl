////////////////////////////////////////////////////////////////////////////////
// конс_ПодключаемаяКонсольСервер: Серверные процедуры и функции консоли кода
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

#Область Инициализация

// Инициализирует редактор на сервере.
// Вызывать в ПриСозданииНаСервере формы.
// 
// Автоматически создаёт все служебные реквизиты формы и привязывает поле HTML.
// На форме должен быть только элемент ПолеHTML без привязки к реквизиту.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - форма с полем HTML
//   ИдентификаторФормы - УникальныйИдентификатор - идентификатор формы для хранилища
//   ПараметрыИнициализации - Структура, Неопределено - дополнительные параметры:
//     * Версия - Строка - версия обработки для кэширования исходников
//     * ИмяПоляHTML - Строка - имя элемента ПолеHTML на форме (по умолчанию "HTML")
//     * ПереопределитьНастройки - Структура - настройки, которые переопределят значения из хранилища
//
// Пример:
//   // С именем поля по умолчанию ("HTML"):
//   конс_ПодключаемаяКонсольСервер.ИнициализироватьРедактор(ЭтотОбъект, УникальныйИдентификатор);
//
//   // С нестандартным именем поля:
//   Параметры = Новый Структура("ИмяПоляHTML", "ПолеРедактора");
//   конс_ПодключаемаяКонсольСервер.ИнициализироватьРедактор(ЭтотОбъект, УникальныйИдентификатор, Параметры);
//
Процедура ИнициализироватьРедактор(Форма, ИдентификаторФормы, ПараметрыИнициализации = Неопределено) Экспорт
	
	// Определяем имя поля HTML
	Если ПараметрыИнициализации <> Неопределено И ПараметрыИнициализации.Свойство("ИмяПоляHTML") Тогда
		ИмяПоляHTML = ПараметрыИнициализации.ИмяПоляHTML;
	Иначе
		ИмяПоляHTML = "HTML";
	КонецЕсли;
	
	// Автоматически добавляем служебные реквизиты и привязываем поле HTML
	ДобавитьСлужебныеРеквизиты(Форма, ИмяПоляHTML);
	
	// Сохраняем имя поля HTML
	Форма.конс_ИмяПоляHTML = ИмяПоляHTML;
	
	// Версия для кэширования исходников
	Если ПараметрыИнициализации <> Неопределено И ПараметрыИнициализации.Свойство("Версия") Тогда
		Форма.конс_ВерсияОбработки = ПараметрыИнициализации.Версия;
	Иначе
		Форма.конс_ВерсияОбработки = "1.0";
	КонецЕсли;
	
	// Инициализация служебных реквизитов
	Форма.конс_ИсходникиЗагружены = Ложь;
	
	// Получаем данные макета с исходниками
	ДанныеМакета = конс_ПодключаемаяКонсольПовтИсп.ПолучитьДанныеМакетаИсходников();
	Если ДанныеМакета <> Неопределено Тогда
		Форма.конс_АдресМакета = ПоместитьВоВременноеХранилище(ДанныеМакета, ИдентификаторФормы);
	КонецЕсли;
	
	// Получаем коллекцию общих модулей для автодополнения (сериализуем в JSON)
	Попытка
		КоллекцияОбщихМодулей = ПолучитьКоллекциюОбщихМодулей();
		ЗаписьJSON = Новый ЗаписьJSON;
		ЗаписьJSON.УстановитьСтроку();
		ЗаписатьJSON(ЗаписьJSON, КоллекцияОбщихМодулей);
		Форма.конс_АдресОбщихМодулей = ПоместитьВоВременноеХранилище(ЗаписьJSON.Закрыть(), ИдентификаторФормы);
	Исключение
		// Игнорируем ошибку - автодополнение общих модулей не критично
	КонецПопытки;
	
	// Загружаем настройки пользователя
	Настройки = ПолучитьНастройкиИзХранилища();
	
	// Переопределяем настройки, если заданы
	Если ПараметрыИнициализации <> Неопределено И ПараметрыИнициализации.Свойство("ПереопределитьНастройки") Тогда
		Для Каждого КлючЗначение Из ПараметрыИнициализации.ПереопределитьНастройки Цикл
			Если Настройки.Свойство(КлючЗначение.Ключ) Тогда
				Настройки.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Сохраняем настройки в форму
	Форма.конс_РежимПоказаПеременных = Настройки.ПоказыватьПеременные;
	Форма.конс_АдресНастроек = ПоместитьВоВременноеХранилище(Настройки, ИдентификаторФормы);
	
КонецПроцедуры

// Добавляет служебные реквизиты формы для работы редактора.
// Вызывается автоматически при инициализации.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//   ИмяПоляHTML - Строка - имя элемента ПолеHTML на форме
//
Процедура ДобавитьСлужебныеРеквизиты(Форма, ИмяПоляHTML)
	
	НовыеРеквизиты = Новый Массив;
	
	// Список служебных реквизитов
	СлужебныеРеквизиты = Новый Структура;
	СлужебныеРеквизиты.Вставить("конс_HTML", Новый ОписаниеТипов("Строка"));
	СлужебныеРеквизиты.Вставить("конс_АдресМакета", Новый ОписаниеТипов("Строка"));
	СлужебныеРеквизиты.Вставить("конс_АдресОбщихМодулей", Новый ОписаниеТипов("Строка"));
	СлужебныеРеквизиты.Вставить("конс_ВерсияОбработки", Новый ОписаниеТипов("Строка"));
	СлужебныеРеквизиты.Вставить("конс_ИмяПоляHTML", Новый ОписаниеТипов("Строка"));
	СлужебныеРеквизиты.Вставить("конс_АдресНастроек", Новый ОписаниеТипов("Строка"));
	СлужебныеРеквизиты.Вставить("конс_АдресХраненияПеременных", Новый ОписаниеТипов("Строка"));
	СлужебныеРеквизиты.Вставить("конс_РежимПоказаПеременных", Новый ОписаниеТипов("Число"));
	СлужебныеРеквизиты.Вставить("конс_ИсходникиЗагружены", Новый ОписаниеТипов("Булево"));
	СлужебныеРеквизиты.Вставить("конс_JSONПеременных", Новый ОписаниеТипов("Строка"));
	СлужебныеРеквизиты.Вставить("конс_JSONФункций", Новый ОписаниеТипов("Строка"));
	СлужебныеРеквизиты.Вставить("конс_JSONСниппетов", Новый ОписаниеТипов("Строка"));
	
	Для Каждого КлючЗначение Из СлужебныеРеквизиты Цикл
		Если Не ЕстьРеквизит(Форма, КлючЗначение.Ключ) Тогда
			НовыеРеквизиты.Добавить(Новый РеквизитФормы(КлючЗначение.Ключ, КлючЗначение.Значение));
		КонецЕсли;
	КонецЦикла;
	
	Если НовыеРеквизиты.Количество() > 0 Тогда
		Форма.ИзменитьРеквизиты(НовыеРеквизиты);
	КонецЕсли;
	
	// Привязываем реквизит конс_HTML к элементу ПолеHTML
	Элемент = Форма.Элементы.Найти(ИмяПоляHTML);
	Если Элемент <> Неопределено И Не ЗначениеЗаполнено(Элемент.ПутьКДанным) Тогда
		Элемент.ПутьКДанным = "конс_HTML";
	КонецЕсли;
	
КонецПроцедуры

// Проверяет наличие реквизита формы.
Функция ЕстьРеквизит(Форма, ИмяРеквизита)
	
	Попытка
		Значение = Форма[ИмяРеквизита];
		Возврат Истина;
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

#КонецОбласти

#Область РаботаСНастройками

// Получает все настройки редактора кода для текущего пользователя.
// 
// Возвращаемое значение:
//   Структура - Настройки редактора:
//     * Тема - Строка - название темы ("СветлаяТема", "ТёмнаяТема" и т.д.)
//     * БыстрыеПодсказки - Булево - включены ли быстрые подсказки
//     * КартаКода - Булево - отображать ли карту кода
//     * ПробелыИТабуляции - Булево - отображать ли пробелы и табуляции
//     * СтрокаСостояния - Булево - отображать ли строку состояния
//     * ПутьКИсходникамКонфигурации - Строка - путь к каталогу с исходниками
//     * ПутьКШаблонамКода - Строка - путь к файлу шаблонов
//     * ПоказыватьПеременные - Число - режим показа переменных (0-не показывать, 1-табло, 2-подсказки)
//     * СохранятьКодПриВыполнении - Булево - сохранять ли код при выполнении
//
Функция ПолучитьНастройкиИзХранилища() Экспорт
	
	Настройки = НастройкиПоУмолчанию();
	
	Попытка
		СохраненныеНастройки = ХранилищеОбщихНастроек.Загрузить("конс_ПодключаемаяКонсольКода", "НастройкиРедактора");
		
		Если ТипЗнч(СохраненныеНастройки) = Тип("Структура") Тогда
			Для Каждого КлючЗначение Из СохраненныеНастройки Цикл
				Если Настройки.Свойство(КлючЗначение.Ключ) Тогда
					Настройки.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	Исключение
		// Используем настройки по умолчанию
	КонецПопытки;
	
	Возврат Настройки;
	
КонецФункции

// Сохраняет настройки редактора кода для текущего пользователя.
// 
// Параметры:
//   Настройки - Структура - Структура с настройками редактора (см. ПолучитьНастройкиИзХранилища)
//
Процедура СохранитьНастройкиВХранилище(Настройки) Экспорт
	
	Попытка
		ХранилищеОбщихНастроек.Сохранить("конс_ПодключаемаяКонсольКода", "НастройкиРедактора", Настройки);
	Исключение
		ВызватьИсключение "Не удалось сохранить настройки редактора: " + ОписаниеОшибки();
	КонецПопытки;
	
КонецПроцедуры

// Возвращает настройки редактора по умолчанию.
// 
// Возвращаемое значение:
//   Структура - Настройки по умолчанию
//
Функция НастройкиПоУмолчанию() Экспорт
	
	Настройки = Новый Структура;
	Настройки.Вставить("Тема", "СветлаяТема");
	Настройки.Вставить("БыстрыеПодсказки", Истина);
	Настройки.Вставить("КартаКода", Истина);
	Настройки.Вставить("ПробелыИТабуляции", Ложь);
	Настройки.Вставить("СтрокаСостояния", Истина);
	Настройки.Вставить("ПутьКИсходникамКонфигурации", "");
	Настройки.Вставить("ПутьКШаблонамКода", "");
	Настройки.Вставить("ПоказыватьПеременные", 1);
	Настройки.Вставить("СохранятьКодПриВыполнении", Ложь);
	Настройки.Вставить("ЯзыкПодсказок", "ru");
	
	Возврат Настройки;
	
КонецФункции

#КонецОбласти

#Область РаботаСМетаданными

// Возвращает описание коллекции общих модулей для автодополнения.
// 
// Возвращаемое значение:
//   Массив - Массив структур с описанием модулей:
//     * Имя - Строка
//     * Синоним - Строка
//     * Контекст - Строка ("Клиент", "Сервер", "ВызовСервера")
//
Функция ПолучитьКоллекциюОбщихМодулей() Экспорт
	
	// Формат для bsl_console: Структура, где ключ - имя модуля, значение - пустая структура
	КоллекцияМодулей = Новый Структура;
	
	Для Каждого ОбщийМодуль Из Метаданные.ОбщиеМодули Цикл
		// Добавляем только неглобальные модули (глобальные вызываются без имени модуля)
		Если Не ОбщийМодуль.Глобальный Тогда
			КоллекцияМодулей.Вставить(ОбщийМодуль.Имя, Новый Структура);
		КонецЕсли;
	КонецЦикла;
	
	Возврат КоллекцияМодулей;
	
КонецФункции

// Возвращает список коллекций метаданных для автодополнения.
// 
// Возвращаемое значение:
//   Структура - Описание метаданных для редактора:
//     * Справочники - Массив
//     * Документы - Массив
//     * Регистры - Массив
//     и т.д.
//
Функция ПолучитьМетаданныеДляРедактора() Экспорт
	
	РезультатМетаданных = Новый Структура;
	
	// Справочники
	Справочники = Новый Массив;
	Для Каждого Справочник Из Метаданные.Справочники Цикл
		Справочники.Добавить(Новый Структура("Имя, Синоним", Справочник.Имя, Справочник.Синоним));
	КонецЦикла;
	РезультатМетаданных.Вставить("Справочники", Справочники);
	
	// Документы
	Документы = Новый Массив;
	Для Каждого Документ Из Метаданные.Документы Цикл
		Документы.Добавить(Новый Структура("Имя, Синоним", Документ.Имя, Документ.Синоним));
	КонецЦикла;
	РезультатМетаданных.Вставить("Документы", Документы);
	
	// Перечисления
	Перечисления = Новый Массив;
	Для Каждого Перечисление Из Метаданные.Перечисления Цикл
		ЗначенияПеречисления = Новый Массив;
		Для Каждого ЗначениеПеречисления Из Перечисление.ЗначенияПеречисления Цикл
			ЗначенияПеречисления.Добавить(ЗначениеПеречисления.Имя);
		КонецЦикла;
		Перечисления.Добавить(Новый Структура("Имя, Синоним, Значения",
			Перечисление.Имя, Перечисление.Синоним, ЗначенияПеречисления));
	КонецЦикла;
	РезультатМетаданных.Вставить("Перечисления", Перечисления);
	
	// Регистры сведений
	РегистрыСведений = Новый Массив;
	Для Каждого РегистрСведений Из Метаданные.РегистрыСведений Цикл
		РегистрыСведений.Добавить(Новый Структура("Имя, Синоним", РегистрСведений.Имя, РегистрСведений.Синоним));
	КонецЦикла;
	РезультатМетаданных.Вставить("РегистрыСведений", РегистрыСведений);
	
	// Регистры накопления
	РегистрыНакопления = Новый Массив;
	Для Каждого РегистрНакопления Из Метаданные.РегистрыНакопления Цикл
		РегистрыНакопления.Добавить(Новый Структура("Имя, Синоним", РегистрНакопления.Имя, РегистрНакопления.Синоним));
	КонецЦикла;
	РезультатМетаданных.Вставить("РегистрыНакопления", РегистрыНакопления);
	
	Возврат РезультатМетаданных;
	
КонецФункции

// Получает данные метаданных по запросу для контекстной подсказки.
// 
// Параметры:
//   ПараметрыЗапроса - Строка - строка запроса метаданных (например, "справочники", "справочники.номенклатура")
//
// Возвращаемое значение:
//   Структура, Неопределено - результат запроса:
//     * Данные - Строка - JSON с данными метаданных
//     * АдресОбновления - Строка - адрес для обновления в редакторе
//
Функция ПолучитьДанныеМетаданныхПоЗапросу(ПараметрыЗапроса) Экспорт
	
	Если СтрНайти(ПараметрыЗапроса, ".") > 0 Тогда
		
		ЧастиЗапроса = СтрРазделить(ПараметрыЗапроса, ".");
		
		Если ЧастиЗапроса[0] = "module" Тогда
			// Запрос структуры модуля
			Если ЧастиЗапроса.Количество() = 2 Тогда
				Возврат ПолучитьСтруктуруОбщегоМодуля(ЧастиЗапроса[1]);
			Иначе
				// Модуль менеджера или объекта - требует более сложной логики
				Возврат Неопределено;
			КонецЕсли;
		Иначе
			// Запрос конкретного объекта метаданных (например, справочники.номенклатура)
			Возврат ПолучитьОписаниеОбъектаМетаданных(ПараметрыЗапроса);
		КонецЕсли;
		
	Иначе
		// Запрос списка объектов коллекции (например, справочники)
		Возврат ПолучитьСписокОбъектовМетаданных(ПараметрыЗапроса);
	КонецЕсли;
	
КонецФункции

// Получает список объектов определённой коллекции метаданных.
Функция ПолучитьСписокОбъектовМетаданных(ИмяКоллекции)
	
	// Получаем имя коллекции для редактора
	ИмяКоллекцииДляРедактора = ПолучитьИмяКоллекцииДляРедактора(ИмяКоллекции);
	
	Если Не ЗначениеЗаполнено(ИмяКоллекцииДляРедактора) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Получаем правильное имя свойства метаданных
	ИмяСвойстваМетаданных = ПолучитьИмяСвойстваМетаданных(ИмяКоллекции);
	
	Если Не ЗначениеЗаполнено(ИмяСвойстваМетаданных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Получаем коллекцию через прямой доступ
	Попытка
		Коллекция = Метаданные[ИмяСвойстваМетаданных];
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Если Коллекция = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Формируем структуру с именами объектов (как в референсе)
	СписокОбъектов = Новый Структура;
	
	Для НомерОбъекта = 0 По Коллекция.Количество() - 1 Цикл
		ОбъектМетаданных = Коллекция.Получить(НомерОбъекта);
		СписокОбъектов.Вставить(ОбъектМетаданных.Имя, Новый Структура);
	КонецЦикла;
	
	// Формируем JSON
	Файл = Новый ЗаписьJSON;
	Файл.УстановитьСтроку();
	ЗаписатьJSON(Файл, СписокОбъектов);
	ДанныеJSON = Файл.Закрыть();
	
	// Определяем адрес обновления
	АдресОбновления = ИмяКоллекцииДляРедактора + ".items";
	
	Возврат Новый Структура("Данные, АдресОбновления", ДанныеJSON, АдресОбновления);
	
КонецФункции

// Получает описание конкретного объекта метаданных.
Функция ПолучитьОписаниеОбъектаМетаданных(ПолноеИмя)
	
	Части = СтрРазделить(ПолноеИмя, ".");
	
	Если Части.Количество() < 2 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИмяКоллекции = Части[0];
	ИмяОбъекта = Части[1];
	
	// Получаем имя коллекции для редактора
	ИмяКоллекцииДляРедактора = ПолучитьИмяКоллекцииДляРедактора(ИмяКоллекции);
	
	Если Не ЗначениеЗаполнено(ИмяКоллекцииДляРедактора) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Получаем правильное имя свойства метаданных
	ИмяСвойстваМетаданных = ПолучитьИмяСвойстваМетаданных(ИмяКоллекции);
	
	Если Не ЗначениеЗаполнено(ИмяСвойстваМетаданных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Получаем объект метаданных через прямой доступ
	Попытка
		ОбъектМетаданных = Метаданные[ИмяСвойстваМетаданных].Найти(ИмяОбъекта);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Если ОбъектМетаданных = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МетаПолноеИмя = ОбъектМетаданных.ПолноеИмя();
	
	// Собираем структуру объекта
	СтруктураОбъекта = Новый Структура;
	ЗаполнитьСтруктуруОбъектаМетаданных(СтруктураОбъекта, ОбъектМетаданных, МетаПолноеИмя);
	
	// Формируем JSON
	Файл = Новый ЗаписьJSON;
	Файл.УстановитьСтроку();
	ЗаписатьJSON(Файл, СтруктураОбъекта);
	ДанныеJSON = Файл.Закрыть();
	
	// Определяем адрес обновления
	АдресОбновления = ИмяКоллекцииДляРедактора + ".items." + ОбъектМетаданных.Имя;
	
	Возврат Новый Структура("Данные, АдресОбновления", ДанныеJSON, АдресОбновления);
	
КонецФункции

// Заполняет структуру объекта метаданных для автодополнения.
Процедура ЗаполнитьСтруктуруОбъектаМетаданных(СтруктураОбъекта, ОбъектМетаданных, ПолноеИмя)
	
	Связи = Новый Соответствие;
	ОписаниеРеквизитов = Новый Структура;
	ОписаниеРесурсов = Новый Структура;
	ОписаниеПредопределенных = Новый Структура;
	ОписаниеТабличныхЧастей = Новый Структура;
	ДополнительныеСвойства = Новый Структура;
	
	// Проверяем тип метаданных - для перечислений особая обработка
	Если ИмяМетаданных(ПолноеИмя) = "Перечисление" Тогда
		// Заполняем значения перечисления
		ЗаполнитьОписаниеЗначенийПеречисления(ОбъектМетаданных, ОписаниеРеквизитов);
	Иначе
		// Стандартные реквизиты
		Попытка
			Для Каждого Реквизит Из ОбъектМетаданных.СтандартныеРеквизиты Цикл
				ДобавитьОписаниеРеквизита(ОписаниеРеквизитов, Реквизит, Связи);
			КонецЦикла;
		Исключение
			// Нет стандартных реквизитов
		КонецПопытки;
		
		// Реквизиты объекта
		Попытка
			Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
				ДобавитьОписаниеРеквизита(ОписаниеРеквизитов, Реквизит, Связи);
			КонецЦикла;
		Исключение
			// Нет реквизитов
		КонецПопытки;
		
		// Измерения и ресурсы (для регистров)
		ЗаполнитьОписаниеИзмеренийРесурсов(ОбъектМетаданных, ПолноеИмя, ОписаниеРеквизитов,
			ОписаниеРесурсов, ДополнительныеСвойства, Связи);
		
		// Табличные части
		ЗаполнитьОписаниеТабличныхЧастей(ОбъектМетаданных, ПолноеИмя, ОписаниеРеквизитов,
			ОписаниеТабличныхЧастей, Связи);
		
		// Предопределенные элементы
		ЗаполнитьОписаниеПредопределенных(ОбъектМетаданных, ПолноеИмя, ОписаниеПредопределенных);
	КонецЕсли;
	
	// Формируем итоговую структуру
	СтруктураОбъекта.Вставить("properties", ОписаниеРеквизитов);
	
	Для Каждого Обход Из ДополнительныеСвойства Цикл
		СтруктураОбъекта.Вставить(Обход.Ключ, Обход.Значение);
	КонецЦикла;
	
	Если ОписаниеРесурсов.Количество() > 0 Тогда
		СтруктураОбъекта.Вставить("resources", ОписаниеРесурсов);
	КонецЕсли;
	
	Если ОписаниеПредопределенных.Количество() > 0 Тогда
		СтруктураОбъекта.Вставить("predefined", ОписаниеПредопределенных);
	КонецЕсли;
	
	Если ОписаниеТабличныхЧастей.Количество() > 0 Тогда
		СтруктураОбъекта.Вставить("tabulars", ОписаниеТабличныхЧастей);
	КонецЕсли;
	
КонецПроцедуры

// Добавляет описание реквизита в структуру.
Процедура ДобавитьОписаниеРеквизита(ОписаниеРеквизитов, Реквизит, Связи)
	
	Связь = ПолучитьСвязьСОбъектомМетаданных(Реквизит, Связи);
	
	ОписаниеРеквизита = Новый Структура("name", Реквизит.Синоним);
	
	Если ЗначениеЗаполнено(Связь) Тогда
		ОписаниеРеквизита.Вставить("ref", Связь);
	КонецЕсли;
	
	ОписаниеРеквизитов.Вставить(Реквизит.Имя, ОписаниеРеквизита);
	
КонецПроцедуры

// Получает связь реквизита с объектом метаданных для навигации.
Функция ПолучитьСвязьСОбъектомМетаданных(Реквизит, Связи)
	
	Связь = "";
	Типы = Реквизит.Тип.Типы();
	Индекс = 0;
	
	Пока Индекс < Типы.Количество() И Не ЗначениеЗаполнено(Связь) Цикл
		
		Тип = Типы[Индекс];
		СвязьТипа = Связи[Тип];
		
		Если СвязьТипа = Неопределено Тогда
			
			ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип);
			
			Если ОбъектМетаданных <> Неопределено Тогда
				
				Если Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
					Связь = "catalogs." + ОбъектМетаданных.Имя;
				ИначеЕсли Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
					Связь = "documents." + ОбъектМетаданных.Имя;
				Иначе
					Связь = "";
				КонецЕсли;
				
			КонецЕсли;
			
			Связи[Тип] = Связь;
			
		Иначе
			Связь = СвязьТипа;
		КонецЕсли;
		
		Индекс = Индекс + 1;
		
	КонецЦикла;
	
	Возврат Связь;
	
КонецФункции

// Заполняет описание значений перечисления.
Процедура ЗаполнитьОписаниеЗначенийПеречисления(ОбъектМетаданных, ОписаниеРеквизитов)
	
	Для НомерРеквизита = 0 По ОбъектМетаданных.ЗначенияПеречисления.Количество() - 1 Цикл
		Реквизит = ОбъектМетаданных.ЗначенияПеречисления.Получить(НомерРеквизита);
		ОписаниеРеквизитов.Вставить(Реквизит.Имя, Новый Структура("name", Реквизит.Синоним));
	КонецЦикла;
	
КонецПроцедуры

// Возвращает имя типа метаданных по полному имени.
Функция ИмяМетаданных(ПолноеИмя)
	
	Части = СтрРазделить(ПолноеИмя, ".");
	Возврат Части[0];
	
КонецФункции

// Проверяет наличие табличных частей у объекта метаданных.
Функция ОбъектМетаданныхИмеетТЧ(ПолноеИмя)
	
	ИмяТипа = ИмяМетаданных(ПолноеИмя);
	
	Возврат ИмяТипа = "Справочник"
		Или ИмяТипа = "Документ"
		Или ИмяТипа = "ПланВидовХарактеристик"
		Или ИмяТипа = "ПланСчетов"
		Или ИмяТипа = "ПланВидовРасчета"
		Или ИмяТипа = "БизнесПроцесс"
		Или ИмяТипа = "Задача"
		Или ИмяТипа = "ПланОбмена";
	
КонецФункции

// Проверяет наличие измерений у объекта метаданных.
Функция ОбъектМетаданныхИмеетИзмерения(ПолноеИмя)
	
	ИмяТипа = ИмяМетаданных(ПолноеИмя);
	
	Возврат ИмяТипа = "РегистрСведений"
		Или ИмяТипа = "РегистрНакопления"
		Или ИмяТипа = "РегистрБухгалтерии"
		Или ИмяТипа = "РегистрРасчета";
	
КонецФункции

// Проверяет наличие предопределенных элементов.
Функция ОбъектМетаданныхИмеетПредопределенные(ПолноеИмя)
	
	ИмяТипа = ИмяМетаданных(ПолноеИмя);
	
	Возврат ИмяТипа = "Справочник"
		Или ИмяТипа = "ПланВидовХарактеристик"
		Или ИмяТипа = "ПланСчетов"
		Или ИмяТипа = "ПланВидовРасчета";
	
КонецФункции

// Заполняет описание измерений и ресурсов регистра.
Процедура ЗаполнитьОписаниеИзмеренийРесурсов(ОбъектМетаданных, ПолноеИмя, ОписаниеРеквизитов,
	ОписаниеРесурсов, ДополнительныеСвойства, Связи)
	
	Если Не ОбъектМетаданныхИмеетИзмерения(ПолноеИмя) Тогда
		Возврат;
	КонецЕсли;
	
	Для НомерРеквизита = 0 По ОбъектМетаданных.Измерения.Количество() - 1 Цикл
		Реквизит = ОбъектМетаданных.Измерения.Получить(НомерРеквизита);
		ДобавитьОписаниеРеквизита(ОписаниеРеквизитов, Реквизит, Связи);
	КонецЦикла;
	
	Для НомерРеквизита = 0 По ОбъектМетаданных.Ресурсы.Количество() - 1 Цикл
		Реквизит = ОбъектМетаданных.Ресурсы.Получить(НомерРеквизита);
		ДобавитьОписаниеРеквизита(ОписаниеРесурсов, Реквизит, Связи);
	КонецЦикла;
	
	// Тип регистра
	ТипРегистра = "";
	
	Если ИмяМетаданных(ПолноеИмя) = "РегистрСведений" Тогда
		
		Непериодический = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический;
		
		Если ОбъектМетаданных.ПериодичностьРегистраСведений = Непериодический Тогда
			ТипРегистра = "nonperiodical";
		Иначе
			ТипРегистра = "periodical";
		КонецЕсли;
		
	ИначеЕсли ИмяМетаданных(ПолноеИмя) = "РегистрНакопления" Тогда
		
		Если ОбъектМетаданных.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
			ТипРегистра = "balance";
		Иначе
			ТипРегистра = "turnovers";
		КонецЕсли;
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ТипРегистра) Тогда
		ДополнительныеСвойства.Вставить("type", ТипРегистра);
	КонецЕсли;
	
КонецПроцедуры

// Заполняет описание табличных частей.
Процедура ЗаполнитьОписаниеТабличныхЧастей(ОбъектМетаданных, ПолноеИмя,
	ОписаниеРеквизитов, ОписаниеТабличныхЧастей, Связи)
	
	Если Не ОбъектМетаданныхИмеетТЧ(ПолноеИмя) Тогда
		Возврат;
	КонецЕсли;
	
	Для НомерРеквизита = 0 По ОбъектМетаданных.ТабличныеЧасти.Количество() - 1 Цикл
		
		ТабличнаяЧасть = ОбъектМетаданных.ТабличныеЧасти.Получить(НомерРеквизита);
		ОписаниеРеквизитов.Вставить(ТабличнаяЧасть.Имя, Новый Структура("name", "ТЧ: " + ТабличнаяЧасть.Синоним));
		
		ОписаниеТабличнойЧасти = Новый Структура;
		
		Для Каждого РеквизитТЧ Из ТабличнаяЧасть.СтандартныеРеквизиты Цикл
			ОписаниеТабличнойЧасти.Вставить(РеквизитТЧ.Имя, РеквизитТЧ.Синоним);
		КонецЦикла;
		
		Для НомерРеквизитаТЧ = 0 По ТабличнаяЧасть.Реквизиты.Количество() - 1 Цикл
			РеквизитТЧ = ТабличнаяЧасть.Реквизиты.Получить(НомерРеквизитаТЧ);
			ДобавитьОписаниеРеквизита(ОписаниеТабличнойЧасти, РеквизитТЧ, Связи);
		КонецЦикла;
		
		СтруктураТабличнойЧасти = Новый Структура;
		СтруктураТабличнойЧасти.Вставить("properties", ОписаниеТабличнойЧасти);
		
		Если ОписаниеТабличнойЧасти.Количество() > 0 Тогда
			ОписаниеТабличныхЧастей.Вставить(ТабличнаяЧасть.Имя, СтруктураТабличнойЧасти);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Заполняет описание предопределенных элементов.
Процедура ЗаполнитьОписаниеПредопределенных(ОбъектМетаданных, ПолноеИмя, ОписаниеПредопределенных)
	
	Если Не ОбъектМетаданныхИмеетПредопределенные(ПолноеИмя) Тогда
		Возврат;
	КонецЕсли;
	
	Попытка
		Предопределенные = ОбъектМетаданных.ПолучитьИменаПредопределенных();
		
		Для Каждого Имя Из Предопределенные Цикл
			ОписаниеПредопределенных.Вставить(Имя, "");
		КонецЦикла;
	Исключение
		// Нет предопределенных
	КонецПопытки;
	
КонецПроцедуры

// Получает структуру общего модуля для автодополнения.
Функция ПолучитьСтруктуруОбщегоМодуля(ИмяМодуля)
	
	// Находим модуль
	МодульМетаданных = Неопределено;
	
	Для Каждого ОбщийМодуль Из Метаданные.ОбщиеМодули Цикл
		Если НРег(ОбщийМодуль.Имя) = НРег(ИмяМодуля) Тогда
			МодульМетаданных = ОбщийМодуль;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если МодульМетаданных = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Получаем экспортные методы модуля (базовая информация)
	СтруктураМодуля = Новый Структура;
	СтруктураМодуля.Вставить("name", МодульМетаданных.Имя);
	СтруктураМодуля.Вставить("description", МодульМетаданных.Синоним);
	
	// Для полного анализа требуется парсинг текста модуля
	// Пока возвращаем базовую структуру
	
	// Формируем JSON
	Файл = Новый ЗаписьJSON;
	Файл.УстановитьСтроку();
	ЗаписатьJSON(Файл, СтруктураМодуля);
	ДанныеJSON = Файл.Закрыть();
	
	АдресОбновления = "module." + МодульМетаданных.Имя;
	
	Возврат Новый Структура("Данные, АдресОбновления", ДанныеJSON, АдресОбновления);
	
КонецФункции

// Получает информацию об общем модуле для загрузки из исходников.
// 
// Параметры:
//   ИмяМодуля - Строка - имя модуля
//
// Возвращаемое значение:
//   Структура, Неопределено - информация о модуле:
//     * ИмяВКонфигураторе - Строка - точное имя модуля в конфигураторе
//     * Глобальный - Булево - является ли модуль глобальным
//
Функция ПолучитьИнформациюОбщегоМодуля(ИмяМодуля) Экспорт
	
	// Находим модуль по имени (без учета регистра)
	Для Каждого ОбщийМодуль Из Метаданные.ОбщиеМодули Цикл
		Если НРег(ОбщийМодуль.Имя) = НРег(ИмяМодуля) Тогда
			Возврат Новый Структура("ИмяВКонфигураторе, Глобальный",
				ОбщийМодуль.Имя,
				ОбщийМодуль.Глобальный);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Получает информацию об объекте метаданных для загрузки модуля из исходников.
// 
// Параметры:
//   КоллекцияМетаданных - Строка - имя коллекции (обработки, справочники и т.д.)
//   ИмяОбъекта - Строка - имя объекта метаданных
//
// Возвращаемое значение:
//   Структура, Неопределено - информация об объекте:
//     * ИмяКаталога - Строка - имя каталога в выгрузке (DataProcessors, Catalogs и т.д.)
//     * ИмяОбъектаВКонфигураторе - Строка - точное имя объекта в конфигураторе
//     * ИмяКоллекцииРедактора - Строка - имя коллекции для редактора (dataProc, catalogs и т.д.)
//
Функция ПолучитьИнформациюОбъектаМетаданных(КоллекцияМетаданных, ИмяОбъекта) Экспорт
	
	// Получаем соответствие русских имен коллекций к английским
	СоответствиеКоллекций = Новый Соответствие;
	СоответствиеКоллекций.Вставить("справочники", "Справочники");
	СоответствиеКоллекций.Вставить("catalogs", "Справочники");
	СоответствиеКоллекций.Вставить("документы", "Документы");
	СоответствиеКоллекций.Вставить("documents", "Документы");
	СоответствиеКоллекций.Вставить("обработки", "Обработки");
	СоответствиеКоллекций.Вставить("dataprocessors", "Обработки");
	СоответствиеКоллекций.Вставить("отчеты", "Отчеты");
	СоответствиеКоллекций.Вставить("reports", "Отчеты");
	СоответствиеКоллекций.Вставить("регистрысведений", "РегистрыСведений");
	СоответствиеКоллекций.Вставить("informationregisters", "РегистрыСведений");
	СоответствиеКоллекций.Вставить("регистрынакопления", "РегистрыНакопления");
	СоответствиеКоллекций.Вставить("accumulationregisters", "РегистрыНакопления");
	СоответствиеКоллекций.Вставить("планыобмена", "ПланыОбмена");
	СоответствиеКоллекций.Вставить("exchangeplans", "ПланыОбмена");
	СоответствиеКоллекций.Вставить("планывидовхарактеристик", "ПланыВидовХарактеристик");
	СоответствиеКоллекций.Вставить("chartsofcharacteristictypes", "ПланыВидовХарактеристик");
	СоответствиеКоллекций.Вставить("бизнеспроцессы", "БизнесПроцессы");
	СоответствиеКоллекций.Вставить("businessprocesses", "БизнесПроцессы");
	СоответствиеКоллекций.Вставить("задачи", "Задачи");
	СоответствиеКоллекций.Вставить("tasks", "Задачи");
	
	// Соответствие коллекций к именам каталогов выгрузки
	СоответствиеКаталогов = Новый Соответствие;
	СоответствиеКаталогов.Вставить("Справочники", "Catalogs");
	СоответствиеКаталогов.Вставить("Документы", "Documents");
	СоответствиеКаталогов.Вставить("Обработки", "DataProcessors");
	СоответствиеКаталогов.Вставить("Отчеты", "Reports");
	СоответствиеКаталогов.Вставить("РегистрыСведений", "InformationRegisters");
	СоответствиеКаталогов.Вставить("РегистрыНакопления", "AccumulationRegisters");
	СоответствиеКаталогов.Вставить("ПланыОбмена", "ExchangePlans");
	СоответствиеКаталогов.Вставить("ПланыВидовХарактеристик", "ChartsOfCharacteristicTypes");
	СоответствиеКаталогов.Вставить("БизнесПроцессы", "BusinessProcesses");
	СоответствиеКаталогов.Вставить("Задачи", "Tasks");
	
	// Определяем коллекцию метаданных
	ИмяКоллекцииМетаданных = СоответствиеКоллекций.Получить(НРег(КоллекцияМетаданных));
	Если ИмяКоллекцииМетаданных = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Получаем коллекцию из метаданных
	Попытка
		Коллекция = Метаданные[ИмяКоллекцииМетаданных];
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	// Ищем объект в коллекции (без учета регистра)
	ОбъектМетаданных = Неопределено;
	Для Каждого Элемент Из Коллекция Цикл
		Если НРег(Элемент.Имя) = НРег(ИмяОбъекта) Тогда
			ОбъектМетаданных = Элемент;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если ОбъектМетаданных = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Формируем результат
	Результат = Новый Структура;
	Результат.Вставить("ИмяКаталога", СоответствиеКаталогов.Получить(ИмяКоллекцииМетаданных));
	Результат.Вставить("ИмяОбъектаВКонфигураторе", ОбъектМетаданных.Имя);
	Результат.Вставить("ИмяКоллекцииРедактора", ПолучитьИмяКоллекцииДляРедактора(КоллекцияМетаданных));
	
	Возврат Результат;
	
КонецФункции

// Читает текст общего модуля из файла исходников.
// 
// Параметры:
//   КаталогИсходногоКода - Строка - путь к каталогу с исходниками
//   ИмяМодуля - Строка - имя модуля
//
// Возвращаемое значение:
//   Структура, Неопределено - данные модуля
//
Функция ПрочитатьТекстОбщегоМодуля(КаталогИсходногоКода, ИмяМодуля) Экспорт
	
	// Получаем информацию о модуле
	ИнформацияМодуля = ПолучитьИнформациюОбщегоМодуля(ИмяМодуля);
	Если ИнформацияМодуля = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Нормализуем путь
	КаталогИсходногоКода = НормализоватьПутьКИсходникам(КаталогИсходногоКода);
	
	// Формируем путь к файлу модуля
	РазделительПути = ПолучитьРазделительПути();
	ФайлМодуля = СтрШаблон("%1CommonModules%2%3%2Ext%2Module.bsl",
		КаталогИсходногоКода, РазделительПути, ИнформацияМодуля.ИмяВКонфигураторе);
	
	// Читаем текст модуля
	ТекстМодуля = ПрочитатьТекстФайла(ФайлМодуля);
	Если ТекстМодуля = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("ИмяМодуля", ИнформацияМодуля.ИмяВКонфигураторе);
	Результат.Вставить("ТекстМодуля", ТекстМодуля);
	Результат.Вставить("Глобальный", ИнформацияМодуля.Глобальный);
	
	Возврат Результат;
	
КонецФункции

// Читает текст модуля объекта (менеджера или объекта) из файла исходников.
// 
// Параметры:
//   КаталогИсходногоКода - Строка - путь к каталогу с исходниками
//   ТипМодуля - Строка - "manager" или "object"
//   КоллекцияМетаданных - Строка - имя коллекции
//   ИмяОбъекта - Строка - имя объекта метаданных
//
// Возвращаемое значение:
//   Структура, Неопределено - данные модуля
//
Функция ПрочитатьТекстМодуляОбъекта(КаталогИсходногоКода, ТипМодуля, КоллекцияМетаданных, ИмяОбъекта) Экспорт
	
	// Получаем информацию об объекте
	ИнформацияОбъекта = ПолучитьИнформациюОбъектаМетаданных(КоллекцияМетаданных, ИмяОбъекта);
	Если ИнформацияОбъекта = Неопределено Тогда

		Возврат Неопределено;
	КонецЕсли;
	
	// Нормализуем путь
	КаталогИсходногоКода = НормализоватьПутьКИсходникам(КаталогИсходногоКода);
	
	// Определяем имя файла модуля
	ИмяФайлаМодуля = ?(НРег(ТипМодуля) = "manager", "ManagerModule", "ObjectModule");
	
	// Формируем путь к файлу модуля
	РазделительПути = ПолучитьРазделительПути();
	ФайлМодуля = СтрШаблон("%1%2%3%4%3Ext%3%5.bsl",
		КаталогИсходногоКода,
		ИнформацияОбъекта.ИмяКаталога,
		РазделительПути,
		ИнформацияОбъекта.ИмяОбъектаВКонфигураторе,
		ИмяФайлаМодуля);
	
	// Читаем текст модуля
	ТекстМодуля = ПрочитатьТекстФайла(ФайлМодуля);
	Если ТекстМодуля = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Формируем адрес загрузки для parseMetadataModule
	АдресЗагрузки = СтрШаблон("%1.items.%2.%3",
		ИнформацияОбъекта.ИмяКоллекцииРедактора,
		ИнформацияОбъекта.ИмяОбъектаВКонфигураторе,
		НРег(ТипМодуля));

	Результат = Новый Структура;
	Результат.Вставить("ТекстМодуля", ТекстМодуля);
	Результат.Вставить("АдресЗагрузки", АдресЗагрузки);
	
	Возврат Результат;
	
КонецФункции

// Нормализует путь к исходникам (добавляет разделитель в конце).
Функция НормализоватьПутьКИсходникам(Путь)
	
	Путь = СокрЛП(Путь);
	РазделительПути = ПолучитьРазделительПути();
	
	Если Прав(Путь, 1) <> РазделительПути Тогда
		Путь = Путь + РазделительПути;
	КонецЕсли;
	
	Возврат Путь;
	
КонецФункции

// Читает текст из файла.
Функция ПрочитатьТекстФайла(ПутьКФайлу)
	
	Файл = Новый Файл(ПутьКФайлу);
	Если Не Файл.Существует() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		Текст = Новый ТекстовыйДокумент();
		Текст.Прочитать(ПутьКФайлу, КодировкаТекста.UTF8);
		Возврат Текст.ПолучитьТекст();
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции

// Получает имя коллекции для редактора (в формате bsl_console).
Функция ПолучитьИмяКоллекцииДляРедактора(ИмяКоллекции)
	
	// Имена коллекций должны соответствовать bsl_console
	СоответствиеИмен = Новый Соответствие;
	СоответствиеИмен.Вставить("справочники", "catalogs");
	СоответствиеИмен.Вставить("catalogs", "catalogs");
	СоответствиеИмен.Вставить("документы", "documents");
	СоответствиеИмен.Вставить("documents", "documents");
	СоответствиеИмен.Вставить("перечисления", "enums");
	СоответствиеИмен.Вставить("enums", "enums");
	СоответствиеИмен.Вставить("регистрысведений", "infoRegs");
	СоответствиеИмен.Вставить("informationregisters", "infoRegs");
	СоответствиеИмен.Вставить("регистрынакопления", "accumRegs");
	СоответствиеИмен.Вставить("accumulationregisters", "accumRegs");
	СоответствиеИмен.Вставить("обработки", "dataProc");
	СоответствиеИмен.Вставить("dataprocessors", "dataProc");
	СоответствиеИмен.Вставить("отчеты", "reports");
	СоответствиеИмен.Вставить("reports", "reports");
	СоответствиеИмен.Вставить("планысчетов", "сhartsOfAccounts");
	СоответствиеИмен.Вставить("chartsofaccounts", "сhartsOfAccounts");
	СоответствиеИмен.Вставить("планывидовхарактеристик", "chartsOfCharacteristicTypes");
	СоответствиеИмен.Вставить("chartsofcharacteristictypes", "chartsOfCharacteristicTypes");
	СоответствиеИмен.Вставить("планывидоврасчета", "chartsOfCalculationTypes");
	СоответствиеИмен.Вставить("chartsofcalculationtypes", "chartsOfCalculationTypes");
	СоответствиеИмен.Вставить("планыобмена", "exchangePlans");
	СоответствиеИмен.Вставить("exchangeplans", "exchangePlans");
	СоответствиеИмен.Вставить("константы", "constants");
	СоответствиеИмен.Вставить("constants", "constants");
	СоответствиеИмен.Вставить("регистрыбухгалтерии", "accountRegs");
	СоответствиеИмен.Вставить("accountingregisters", "accountRegs");
	СоответствиеИмен.Вставить("регистрырасчета", "calcRegs");
	СоответствиеИмен.Вставить("calculationregisters", "calcRegs");
	СоответствиеИмен.Вставить("бизнеспроцессы", "businessProcesses");
	СоответствиеИмен.Вставить("businessprocesses", "businessProcesses");
	СоответствиеИмен.Вставить("задачи", "tasks");
	СоответствиеИмен.Вставить("tasks", "tasks");
	СоответствиеИмен.Вставить("внешниеисточникиданных", "externalDataSources");
	СоответствиеИмен.Вставить("externaldatasources", "externalDataSources");
	
	Результат = СоответствиеИмен.Получить(НРег(ИмяКоллекции));
	
	Если Результат = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Получает правильное имя свойства коллекции метаданных из строки в любом регистре.
Функция ПолучитьИмяСвойстваМетаданных(ИмяКоллекции)
	
	// Маппинг имён в нижнем регистре на правильные имена свойств Metadata
	СоответствиеИмен = Новый Соответствие;
	СоответствиеИмен.Вставить("справочники", "Справочники");
	СоответствиеИмен.Вставить("catalogs", "Справочники");
	СоответствиеИмен.Вставить("документы", "Документы");
	СоответствиеИмен.Вставить("documents", "Документы");
	СоответствиеИмен.Вставить("перечисления", "Перечисления");
	СоответствиеИмен.Вставить("enums", "Перечисления");
	СоответствиеИмен.Вставить("регистрысведений", "РегистрыСведений");
	СоответствиеИмен.Вставить("informationregisters", "РегистрыСведений");
	СоответствиеИмен.Вставить("регистрынакопления", "РегистрыНакопления");
	СоответствиеИмен.Вставить("accumulationregisters", "РегистрыНакопления");
	СоответствиеИмен.Вставить("обработки", "Обработки");
	СоответствиеИмен.Вставить("dataprocessors", "Обработки");
	СоответствиеИмен.Вставить("отчеты", "Отчеты");
	СоответствиеИмен.Вставить("reports", "Отчеты");
	СоответствиеИмен.Вставить("планысчетов", "ПланыСчетов");
	СоответствиеИмен.Вставить("chartsofaccounts", "ПланыСчетов");
	СоответствиеИмен.Вставить("планывидовхарактеристик", "ПланыВидовХарактеристик");
	СоответствиеИмен.Вставить("chartsofcharacteristictypes", "ПланыВидовХарактеристик");
	СоответствиеИмен.Вставить("планывидоврасчета", "ПланыВидовРасчета");
	СоответствиеИмен.Вставить("chartsofcalculationtypes", "ПланыВидовРасчета");
	СоответствиеИмен.Вставить("планыобмена", "ПланыОбмена");
	СоответствиеИмен.Вставить("exchangeplans", "ПланыОбмена");
	СоответствиеИмен.Вставить("константы", "Константы");
	СоответствиеИмен.Вставить("constants", "Константы");
	СоответствиеИмен.Вставить("регистрыбухгалтерии", "РегистрыБухгалтерии");
	СоответствиеИмен.Вставить("accountingregisters", "РегистрыБухгалтерии");
	СоответствиеИмен.Вставить("регистрырасчета", "РегистрыРасчета");
	СоответствиеИмен.Вставить("calculationregisters", "РегистрыРасчета");
	СоответствиеИмен.Вставить("бизнеспроцессы", "БизнесПроцессы");
	СоответствиеИмен.Вставить("businessprocesses", "БизнесПроцессы");
	СоответствиеИмен.Вставить("задачи", "Задачи");
	СоответствиеИмен.Вставить("tasks", "Задачи");
	СоответствиеИмен.Вставить("внешниеисточникиданных", "ВнешниеИсточникиДанных");
	СоответствиеИмен.Вставить("externaldatasources", "ВнешниеИсточникиДанных");
	
	Возврат СоответствиеИмен.Получить(НРег(ИмяКоллекции));
	
КонецФункции

#КонецОбласти

#Область ВыполнениеКода

// Выполняет код на сервере и возвращает результат.
// 
// Параметры:
//   Код - Строка - BSL-код для выполнения
//   РежимПоказаПеременных - ПеречислениеСсылка.конс_РежимПоказаПеременных - режим отображения результатов
//
// Возвращаемое значение:
//   Структура - Результат выполнения:
//     * Успешно - Булево
//     * ОписаниеОшибки - Строка - текст ошибки (для обратной совместимости)
//     * ИнформацияОбОшибке - Структура, Неопределено - полная информация об ошибке:
//         ** Описание - Строка
//         ** НомерСтроки - Число
//         ** НомерКолонки - Число
//         ** ИмяМодуля - Строка
//         ** ИсходнаяСтрока - Строка
//         ** Причина - Структура, Неопределено
//     * ИсходнаяСтрока - Строка (устаревшее, используйте ИнформацияОбОшибке)
//     * ОписаниеПеременных - Строка (JSON)
//     * АдресХраненияПеременных - Строка
//
Функция ВыполнитьКодНаСервере(Код, РежимПоказаПеременных) Экспорт
	
	Результат = НовыйРезультатВыполнения();
	ЗначенияПеременных = Новый Структура;
	
	Попытка
		Выполнить(Код);
		Результат.Успешно = Истина;
		
		АдресПеременных = "";
		Попытка
			Если РежимПоказаПеременных = Перечисления.конс_РежимПоказаПеременных.ВТабло Тогда
				Результат.ОписаниеПеременных = ПолучитьОписаниеПеременныхДляТабло(ЗначенияПеременных, АдресПеременных);
			ИначеЕсли РежимПоказаПеременных = Перечисления.конс_РежимПоказаПеременных.ВПодсказках Тогда
				Результат.ОписаниеПеременных = ПолучитьОписаниеПеременныхДляПодсказок(ЗначенияПеременных);
			КонецЕсли;
			Результат.АдресХраненияПеременных = АдресПеременных;
		Исключение
			Результат.ОписаниеПеременных = "";
		КонецПопытки;
		
	Исключение
		ИнфоОшибки = ИнформацияОбОшибке();
		
		// Полная информация об ошибке (новый формат)
		Результат.ИнформацияОбОшибке = РазобратьИнформациюОбОшибкеСервер(ИнфоОшибки);
		
		//// Обратная совместимость
		//Результат.ИсходнаяСтрока = ИнфоОшибки.ИсходнаяСтрока;
		//Если ИнфоОшибки.Причина <> Неопределено Тогда
		//	Результат.ОписаниеОшибки = ИнфоОшибки.Причина.Описание;
		//Иначе
		//	Результат.ОписаниеОшибки = ИнфоОшибки.Описание;
		//КонецЕсли;
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Возвращает структуру результата выполнения кода.
// 
// Возвращаемое значение:
//   Структура - Пустая структура результата
//
Функция НовыйРезультатВыполнения() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Успешно", Ложь);
	Результат.Вставить("ИсходнаяСтрока", "");
	Результат.Вставить("ОписаниеОшибки", "");
	Результат.Вставить("ИнформацияОбОшибке", Неопределено);
	Результат.Вставить("ОписаниеПеременных", "");
	Результат.Вставить("АдресХраненияПеременных", "");
	
	Возврат Результат;
	
КонецФункции

// Разбирает ИнформациюОбОшибке в структуру.
// 
// Параметры:
//   ИнфоОшибки - ИнформацияОбОшибке
//
// Возвращаемое значение:
//   Структура - Описание ошибки
//
Функция РазобратьИнформациюОбОшибкеСервер(ИнфоОшибки) Экспорт
	
	Если ИнфоОшибки = Неопределено Тогда
		Возврат НовоеОписаниеОшибки();
	КонецЕсли;
	
	// Получаем полный стек ошибки и парсим его с конца к началу
	ПолныйТекст = ПодробноеПредставлениеОшибки(ИнфоОшибки);
	
	Возврат РазобратьСтекОшибкиСервер(ПолныйТекст, ИнфоОшибки.Описание);
	
КонецФункции

// Разбирает стек ошибки из ПодробноеПредставлениеОшибки.
// Идёт с конца к началу, находит строку выполняемого кода {(номер)}.
// 
// Параметры:
//   ПолныйТекст - Строка - результат ПодробноеПредставлениеОшибки
//   ОписаниеОшибки - Строка - текст ошибки (первопричина)
//
// Возвращаемое значение:
//   Структура - разобранная информация об ошибке
//
Функция РазобратьСтекОшибкиСервер(ПолныйТекст, ОписаниеОшибки)
	
	Результат = Новый Структура;
	Результат.Вставить("Описание", ОписаниеОшибки);
	Результат.Вставить("НомерСтроки", 0);
	Результат.Вставить("НомерКолонки", 1);
	Результат.Вставить("ЭтоВыполняемыйКод", Ложь);
	Результат.Вставить("ИмяМодуля", "");
	Результат.Вставить("ИсходнаяСтрока", "");
	Результат.Вставить("СтекВызовов", Новый Массив); // Внешние вызовы (причина)
	Результат.Вставить("Причина", Неопределено);
	
	// Разбиваем на строки
	СтрокиСтека = СтрРазделить(ПолныйТекст, Символы.ПС, Ложь);
	
	// Идём с конца к началу, ищем {(номер)} - это выполняемый код
	НайденаСтрокаКода = Ложь;
	ИндексСтрокиКода = -1;
	
	Индекс = СтрокиСтека.ВГраница();
	Пока Индекс > 0 Цикл
		Строка = СтрокиСтека[Индекс];
		
		// Ищем паттерн {(номер - начало строки с {( означает выполняемый код
		Если СтрНачинаетсяС(СокрЛ(Строка), "{(") Тогда
			// Нашли строку выполняемого кода!
			НайденаСтрокаКода = Истина;
			ИндексСтрокиКода = Индекс;
			
			// Извлекаем номер строки
			Позиция = ИзвлечьПозициюВыполняемогоКодаСервер(Строка);
			Результат.НомерСтроки = Позиция.НомерСтроки;
			Результат.НомерКолонки = Позиция.НомерКолонки;
			Результат.ЭтоВыполняемыйКод = Истина;
			
			// Извлекаем исходную строку (после }:)
			ПозицияДвоеточия = СтрНайти(Строка, "}:");
			Если ПозицияДвоеточия > 0 Тогда
				Результат.ИсходнаяСтрока = СокрЛП(Сред(Строка, ПозицияДвоеточия + 2));
			КонецЕсли;
			
			Прервать;
		КонецЕсли;
		
		Индекс = Индекс - 1;
	КонецЦикла;
	
	// Собираем стек внешних вызовов (всё что ВЫШЕ найденной строки кода, кроме первой строки с текстом ошибки)
	Если НайденаСтрокаКода И ИндексСтрокиКода > 0 Тогда
		Для Индекс = ИндексСтрокиКода - 1 По 1 Цикл
			Строка = СокрЛП(СтрокиСтека[Индекс]);
			
			// Пропускаем пустые строки
			Если Не ЗначениеЗаполнено(Строка) Тогда
				Продолжить;
			КонецЕсли;
			
			// Пропускаем строки с {( - это тоже выполняемый код
			Если СтрНачинаетсяС(Строка, "{(") Тогда
				Продолжить;
			КонецЕсли;
			
			// Это внешний вызов
			Результат.СтекВызовов.Добавить(Строка);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Извлекает позицию из описания ошибки выполняемого кода.
// Формат: {(строка,колонка)}:...
//
Функция ИзвлечьПозициюВыполняемогоКодаСервер(ОписаниеОшибки)
	
	Результат = Новый Структура("НомерСтроки, НомерКолонки", 0, 1);
	
	// Проверяем формат {(строка,колонка)}:...
	Если Не СтрНачинаетсяС(СокрЛ(ОписаниеОшибки), "{(") Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Ищем закрывающую скобку после {(
	ПозицияЗакрытия = СтрНайти(ОписаниеОшибки, ")");
	Если ПозицияЗакрытия <= 2 Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Находим позицию {(
	ПозицияНачала = СтрНайти(ОписаниеОшибки, "{(");
	
	// Извлекаем координаты между {( и )
	Координаты = Сред(ОписаниеОшибки, ПозицияНачала + 2, ПозицияЗакрытия - ПозицияНачала - 2);
	Части = СтрРазделить(Координаты, ",");
	
	Если Части.Количество() >= 1 Тогда
		Попытка
			Результат.НомерСтроки = Макс(0, Число(СокрЛП(Части[0])));
		Исключение
			// Не число
		КонецПопытки;
	КонецЕсли;
	
	Если Части.Количество() >= 2 Тогда
		Попытка
			Результат.НомерКолонки = Макс(1, Число(СокрЛП(Части[1])));
		Исключение
			// Не число
		КонецПопытки;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Создает пустую структуру описания ошибки.
//
Функция НовоеОписаниеОшибки() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Описание", "");
	Результат.Вставить("НомерСтроки", 0);
	Результат.Вставить("НомерКолонки", 1);
	Результат.Вставить("ИмяМодуля", "");
	Результат.Вставить("ИсходнаяСтрока", "");
	Результат.Вставить("СтекВызовов", Новый Массив);
	Результат.Вставить("ЭтоВыполняемыйКод", Ложь);
	Результат.Вставить("Причина", Неопределено);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ВнешнееВыполнениеКода

// Создаёт контекст для внешнего выполнения кода.
// Контекст содержит временное хранилище для переменных и другие служебные данные.
// 
// Параметры:
//   ИдентификаторФормы - УникальныйИдентификатор - идентификатор формы для привязки хранилища
//   РежимПоказаПеременных - Число - режим отображения переменных:
//                           0 - не показывать
//                           1 - показывать в табло
//                           2 - показывать в подсказках
//
// Возвращаемое значение:
//   Структура - контекст выполнения:
//     * АдресХраненияПеременных - Строка - адрес временного хранилища для переменных
//     * РежимПоказаПеременных - Число - режим отображения
//     * КодИнициализацииПеременных - Строка - код для объявления ЗначенияПеременных
//
// Пример:
//   // На сервере создаём контекст
//   Контекст = конс_ПодключаемаяКонсольСервер.СоздатьКонтекстВыполнения(УникальныйИдентификатор, 1);
//   
//   // На клиенте используем
//   Код = Контекст.КодИнициализацииПеременных + ИсходныйКод + КодСбораПеременных;
//   Попытка
//       Выполнить(Код);
//   Исключение
//       // Обработка ошибки
//   КонецПопытки;
//
Функция СоздатьКонтекстВыполнения(ИдентификаторФормы, РежимПоказаПеременных = 1) Экспорт
	
	Контекст = Новый Структура;
	
	// Создаём временное хранилище для переменных
	ДанныеХранилища = Новый Структура;
	ДанныеХранилища.Вставить("ХранилищеПеременных", Новый Структура);
	ДанныеХранилища.Вставить("КэшСсылок", Новый Соответствие);
	
	АдресХраненияПеременных = ПоместитьВоВременноеХранилище(ДанныеХранилища, ИдентификаторФормы);
	
	Контекст.Вставить("АдресХраненияПеременных", АдресХраненияПеременных);
	Контекст.Вставить("РежимПоказаПеременных", РежимПоказаПеременных);
	Контекст.Вставить("КодИнициализацииПеременных", "ЗначенияПеременных = Новый Структура;" + Символы.ПС);
	
	Возврат Контекст;
	
КонецФункции

// Формирует результат выполнения на основе контекста и информации об ошибке.
// Вызывается после внешнего Выполнить для обработки результата.
// 
// Параметры:
//   ЗначенияПеременных - Структура - значения переменных после выполнения
//   ИнформацияОбОшибке - ИнформацияОбОшибке, Неопределено - ошибка выполнения или Неопределено при успехе
//   АдресХраненияПеременных - Строка - адрес хранилища из контекста
//   РежимПоказаПеременных - Число - режим отображения переменных
// Формирует результат выполнения на основе контекста и информации об ошибке.
// Вызывается после внешнего Выполнить для обработки результата.
// 
// Параметры:
//   ЗначенияПеременных - Структура - значения переменных после выполнения
//   ИнформацияОбОшибке - ИнформацияОбОшибке, Структура, Неопределено - ошибка выполнения или Неопределено при успехе.
//                        Может быть ИнформацияОбОшибке (при серверном вызове) 
//                        или Структура (при передаче с клиента, полученная через РазобратьИнформациюОбОшибкеКлиент)
//   АдресХраненияПеременных - Строка - адрес хранилища из контекста
//   РежимПоказаПеременных - Число - режим отображения переменных
//
// Возвращаемое значение:
//   Структура - результат выполнения (см. НовыйРезультатВыполнения)
//
// Пример:
//   ЗначенияПеременных = Новый Структура;
//   ИнфоОшибки = Неопределено;
//   
//   Попытка
//       Выполнить(КодСПеременными);
//   Исключение
//       ИнфоОшибки = ИнформацияОбОшибке();
//   КонецПопытки;
//   
//   Результат = конс_ПодключаемаяКонсольСервер.СформироватьРезультатВыполнения(
//       ЗначенияПеременных, ИнфоОшибки, Контекст.АдресХраненияПеременных, Контекст.РежимПоказаПеременных);
//
Функция СформироватьРезультатВыполнения(ЗначенияПеременных, ИнформацияОбОшибке, АдресХраненияПеременных, РежимПоказаПеременных) Экспорт
	
	Результат = НовыйРезультатВыполнения();
	
	Если ИнформацияОбОшибке = Неопределено Тогда
		Результат.Успешно = Истина;
		
		// Сериализуем переменные в соответствии с режимом
		Попытка
			Если РежимПоказаПеременных = 1 Тогда
				// Режим табло
				АдресПеременных = АдресХраненияПеременных;
				Результат.ОписаниеПеременных = ПолучитьОписаниеПеременныхДляТабло(ЗначенияПеременных, АдресПеременных);
				Результат.АдресХраненияПеременных = АдресПеременных;
			ИначеЕсли РежимПоказаПеременных = 2 Тогда
				// Режим подсказок
				Результат.ОписаниеПеременных = ПолучитьОписаниеПеременныхДляПодсказок(ЗначенияПеременных);
				Результат.АдресХраненияПеременных = АдресХраненияПеременных;
			Иначе
				Результат.ОписаниеПеременных = "";
			КонецЕсли;
		Исключение
			Результат.ОписаниеПеременных = "";
		КонецПопытки;
	Иначе
		// Если передана структура (с клиента) - используем как есть
		// Если передан ИнформацияОбОшибке (серверный вызов) - разбираем
		Если ТипЗнч(ИнформацияОбОшибке) = Тип("Структура") Тогда
			Результат.ИнформацияОбОшибке = ИнформацияОбОшибке;
		Иначе
			Результат.ИнформацияОбОшибке = РазобратьИнформациюОбОшибкеСервер(ИнформацияОбОшибке);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Освобождает контекст выполнения и удаляет временное хранилище.
// 
// Параметры:
//   АдресХраненияПеременных - Строка - адрес хранилища из контекста
//
Процедура ОсвободитьКонтекстВыполнения(АдресХраненияПеременных) Экспорт
	
	Если ЭтоАдресВременногоХранилища(АдресХраненияПеременных) Тогда
		УдалитьИзВременногоХранилища(АдресХраненияПеременных);
	КонецЕсли;
	
КонецПроцедуры

// Формирует код для сбора значений переменных.
// 
// Параметры:
//   ИменаПеременных - Массив - массив имён переменных для сбора
//
// Возвращаемое значение:
//   Строка - код BSL для сбора переменных в структуру ЗначенияПеременных
//
Функция СформироватьКодСбораПеременных(ИменаПеременных) Экспорт
	
	Если ИменаПеременных = Неопределено Или ИменаПеременных.Количество() = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	ПС = Символы.ПС;
	Код = "";
	
	Для Каждого Имя Из ИменаПеременных Цикл
		Код = Код + ПС + "Попытка ЗначенияПеременных.Вставить(""" + Имя + """, Вычислить(""" + Имя + """)); Исключение КонецПопытки;";
	КонецЦикла;
	
	Возврат Код;
	
КонецФункции

// Создаёт временное хранилище для переменных внешнего выполнения.
// 
// Параметры:
//   ИдентификаторФормы - УникальныйИдентификатор - идентификатор формы для привязки хранилища
//
// Возвращаемое значение:
//   Строка - адрес временного хранилища
//
Функция СоздатьВременноеХранилищеПеременных(ИдентификаторФормы) Экспорт
	
	// Создаём пустую структуру - она будет заменена при выполнении кода
	Возврат ПоместитьВоВременноеХранилище(Новый Структура, ИдентификаторФормы);
	
КонецФункции

// Обрабатывает результат внешнего выполнения кода.
// Получает переменные из хранилища и формирует структуру результата.
// 
// Параметры:
//   АдресХраненияПеременных - Строка - адрес хранилища с переменными
//   ИнформацияОбОшибке - Структура, Неопределено - разобранная информация об ошибке
//   РежимПоказаПеременных - Число - режим отображения переменных
//
// Возвращаемое значение:
//   Структура - результат выполнения
//
Функция ОбработатьРезультатВнешнегоВыполнения(АдресХраненияПеременных, ИнформацияОбОшибке, РежимПоказаПеременных) Экспорт
	
	Результат = НовыйРезультатВыполнения();
	
	Если ИнформацияОбОшибке <> Неопределено Тогда
		// Была ошибка выполнения
		Результат.ИнформацияОбОшибке = ИнформацияОбОшибке;
		Возврат Результат;
	КонецЕсли;
	
	Результат.Успешно = Истина;
	
	// Получаем переменные из хранилища
	ЗначенияПеременных = Новый Структура;
	Если ЭтоАдресВременногоХранилища(АдресХраненияПеременных) Тогда
		ДанныеИзХранилища = ПолучитьИзВременногоХранилища(АдресХраненияПеременных);
		Если ТипЗнч(ДанныеИзХранилища) = Тип("Структура") Тогда
			ЗначенияПеременных = ДанныеИзХранилища;
		КонецЕсли;
	КонецЕсли;
	
	// Сериализуем переменные в соответствии с режимом
	Попытка
		Если РежимПоказаПеременных = 1 Тогда
			// Режим табло
			АдресПеременных = "";
			Результат.ОписаниеПеременных = ПолучитьОписаниеПеременныхДляТабло(ЗначенияПеременных, АдресПеременных);
			Результат.АдресХраненияПеременных = АдресПеременных;
		ИначеЕсли РежимПоказаПеременных = 2 Тогда
			// Режим подсказок
			Результат.ОписаниеПеременных = ПолучитьОписаниеПеременныхДляПодсказок(ЗначенияПеременных);
		Иначе
			Результат.ОписаниеПеременных = "";
		КонецЕсли;
	Исключение
		Результат.ОписаниеПеременных = "";
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ВыводВТабло

// Получает описание переменных для вывода в табло.
// 
// Параметры:
//   ЗначенияПеременных - Структура - переменные и их значения
//   АдресХраненияПеременных - Строка - возвращаемый адрес хранилища
//
// Возвращаемое значение:
//   Строка - JSON-описание переменных для табло
//
Функция ПолучитьОписаниеПеременныхДляТабло(ЗначенияПеременных, АдресХраненияПеременных) Экспорт
	
	Описание = Новый Структура;
	КэшСсылок = Новый Соответствие;
	ХранилищеПеременных = Новый Структура;
	
	Для Каждого КлючЗначение Из ЗначенияПеременных Цикл
		ИдентификаторПеременной = НовыйИдентификаторПеременной();
		Переменная = ПолучитьКраткуюСтруктуруПеременной(КлючЗначение.Значение, КлючЗначение.Ключ, "", КэшСсылок);
		Описание.Вставить(ИдентификаторПеременной, Переменная);
		ХранилищеПеременных.Вставить(ИдентификаторПеременной, КлючЗначение.Значение);
	КонецЦикла;
	
	Данные = Новый Структура;
	Данные.Вставить("ХранилищеПеременных", ХранилищеПеременных);
	Данные.Вставить("КэшСсылок", КэшСсылок);
	
	АдресХраненияПеременных = ПоместитьВоВременноеХранилище(Данные, Новый УникальныйИдентификатор);
	
	Запись = Новый ЗаписьJSON;
	Запись.УстановитьСтроку();
	ЗаписатьJSON(Запись, Описание);
	
	Возврат Запись.Закрыть();
	
КонецФункции

// Получает описание переменных для всплывающих подсказок.
// 
// Параметры:
//   ЗначенияПеременных - Структура - переменные и их значения
//
// Возвращаемое значение:
//   Строка - JSON-описание переменных для подсказок
//
Функция ПолучитьОписаниеПеременныхДляПодсказок(ЗначенияПеременных) Экспорт
	
	Описание = Новый Структура;
	КэшСсылок = Новый Соответствие;
	
	Для Каждого КлючЗначение Из ЗначенияПеременных Цикл
		Представление = ПолучитьПредставлениеПеременной(КлючЗначение.Значение, -1, КэшСсылок);
		Описание.Вставить(КлючЗначение.Ключ, Представление);
	КонецЦикла;
	
	Запись = Новый ЗаписьJSON;
	Запись.УстановитьСтроку();
	ЗаписатьJSON(Запись, Описание);
	
	Возврат Запись.Закрыть();
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция НовыйИдентификаторПеременной()
	
	Возврат "var_" + СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "");
	
КонецФункции

// Получает краткую структуру переменной для табло.
//
Функция ПолучитьКраткуюСтруктуруПеременной(Значение, Имя, ПутьКДанным, КэшСсылок)
	
	Представление = "";
	ТипЗнч = ТипЗнч(Значение);
	Картинка = "";
	Класс = "";
	
	Если ТипЗнч = Тип("Число") Тогда
		Представление = Строка(Значение);
		Картинка = "int";
		Класс = "final";
	ИначеЕсли ТипЗнч = Тип("Строка") Тогда
		Представление = Значение;
		Картинка = "string";
		Класс = "final";
	ИначеЕсли ТипЗнч = Тип("Булево") Тогда
		Представление = Строка(Значение);
		Картинка = "boolean";
		Класс = "final";
	ИначеЕсли ТипЗнч = Тип("Дата") Тогда
		Представление = Строка(Значение);
		Картинка = "date";
		Класс = "final";
	ИначеЕсли Значение = Неопределено Тогда
		Представление = "Неопределено";
		Класс = "final";
	ИначеЕсли ТипЗнч = Тип("Null") Тогда
		Картинка = "null";
		Класс = "final";
	ИначеЕсли ТипЗнч = Тип("Структура") Или ТипЗнч = Тип("Соответствие") Тогда
		Представление = СтрШаблон("%1 (%2)", Строка(ТипЗнч), Значение.Количество());
		Картинка = "array";
		Если Значение.Количество() = 0 Тогда
			Класс = "final";
		КонецЕсли;
	ИначеЕсли ТипЗнч = Тип("Массив") Или ТипЗнч = Тип("СписокЗначений") Тогда
		Представление = СтрШаблон("%1 (%2)", Строка(ТипЗнч), Значение.Количество());
		Картинка = "array";
		Если Значение.Количество() = 0 Тогда
			Класс = "final";
		КонецЕсли;
	ИначеЕсли ТипЗнч = Тип("ТаблицаЗначений") Тогда
		Представление = СтрШаблон("%1 (%2)", Строка(ТипЗнч), Значение.Количество());
		Картинка = "table";
		Если Значение.Количество() = 0 Тогда
			Класс = "final";
		КонецЕсли;
	ИначеЕсли ТипЗнч = Тип("ДеревоЗначений") Тогда
		Представление = СтрШаблон("%1 (%2)", Строка(ТипЗнч), Значение.Строки.Количество());
		Картинка = "tree";
		Если Значение.Строки.Количество() = 0 Тогда
			Класс = "final";
		КонецЕсли;
	ИначеЕсли ТипЗнч = Тип("Запрос") Тогда
		Представление = Строка(ТипЗнч);
		Картинка = "query";
	ИначеЕсли ЭтоСсылка(Значение) Тогда
		Попытка
			Если Не Значение.Пустая() Тогда
				Ссылка = ПолучитьНавигационнуюСсылку(Значение);
				Представление = СтрШаблон("<a href='%1'>%2</a>", Ссылка, Строка(Значение));
			Иначе
				Представление = "";
			КонецЕсли;
		Исключение
			Представление = Строка(Значение);
		КонецПопытки;
		Картинка = "catalog";
	Иначе
		Попытка
			Представление = Строка(Значение);
		Исключение
			Представление = Строка(ТипЗнч);
		КонецПопытки;
		Класс = "final";
	КонецЕсли;
	
	Переменная = Новый Структура;
	Переменная.Вставить("label", Имя);
	Переменная.Вставить("value", Представление);
	Переменная.Вставить("type", Строка(ТипЗнч));
	Переменная.Вставить("path", ПутьКДанным);
	Переменная.Вставить("class", Класс);
	
	Если ЗначениеЗаполнено(Картинка) Тогда
		Переменная.Вставить("icon", Картинка + ".png");
	КонецЕсли;
	
	Возврат Переменная;
	
КонецФункции

// Получает текстовое представление переменной для подсказок.
//
Функция ПолучитьПредставлениеПеременной(Значение, Знач Смещение, КэшСсылок)
	
	Представление = "";
	ТипЗнч = ТипЗнч(Значение);
	
	Смещение = Смещение + 1;
	
	Если ТипЗнч = Тип("Число") Или ТипЗнч = Тип("Строка")
		Или ТипЗнч = Тип("Булево") Или ТипЗнч = Тип("Дата") Тогда
		Представление = Строка(Значение);
	ИначеЕсли Значение = Неопределено Тогда
		Представление = "Неопределено";
	ИначеЕсли ТипЗнч = Тип("Null") Тогда
		Представление = "Null";
	ИначеЕсли ТипЗнч = Тип("Структура") Или ТипЗнч = Тип("Соответствие") Тогда
		Представление = ПолучитьПредставлениеСтруктурыСоответствия(Значение, Смещение, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("Массив") Или ТипЗнч = Тип("СписокЗначений") Тогда
		Представление = ПолучитьПредставлениеМассиваСписка(Значение, Смещение, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("ТаблицаЗначений") Тогда
		Представление = СтрШаблон("**Таблица значений (%1):**", Значение.Количество());
	ИначеЕсли ТипЗнч = Тип("ДеревоЗначений") Тогда
		Представление = СтрШаблон("**Дерево значений (%1):**", Значение.Строки.Количество());
	ИначеЕсли ТипЗнч = Тип("Запрос") Тогда
		Представление = "**Запрос**";
	ИначеЕсли ЭтоСсылка(Значение) Тогда
		Попытка
			Если Не Значение.Пустая() Тогда
				НавСсылка = ПолучитьНавигационнуюСсылку(Значение);
				Представление = СтрШаблон("[%1](%2)", Строка(Значение), НавСсылка);
			Иначе
				Представление = "";
			КонецЕсли;
		Исключение
			Представление = Строка(Значение);
		КонецПопытки;
	Иначе
		Попытка
			Представление = Строка(Значение);
		Исключение
			Представление = Строка(ТипЗнч);
		КонецПопытки;
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции

Функция ПолучитьПредставлениеСтруктурыСоответствия(Значение, Смещение, КэшСсылок)
	
	Строки = Новый Массив;
	Строки.Добавить(СтрШаблон("**%1 (%2)**:", ТипЗнч(Значение), Значение.Количество()));
	
	Для Каждого КлючЗначение Из Значение Цикл
		Маркер = ДополнитьСтроку("- ", Смещение * 4, " ");
		Строки.Добавить(Маркер + КлючЗначение.Ключ + ": " + ПолучитьПредставлениеПеременной(КлючЗначение.Значение, Смещение, КэшСсылок));
	КонецЦикла;
	
	Возврат СтрСоединить(Строки, Символы.ПС);
	
КонецФункции

Функция ПолучитьПредставлениеМассиваСписка(Значение, Смещение, КэшСсылок)
	
	Строки = Новый Массив;
	ТипЗнч = ТипЗнч(Значение);
	ЭтоМассив = (ТипЗнч = Тип("Массив"));
	
	Строки.Добавить(СтрШаблон("**%1 (%2)**:", ТипЗнч, Значение.Количество()) + Символы.ПС);
	
	Индекс = 0;
	Для Каждого Элемент Из Значение Цикл
		Маркер = ДополнитьСтроку("- (" + Индекс + ") ", Смещение * 4, " ");
		
		Если ЭтоМассив Тогда
			Строки.Добавить(Маркер + ПолучитьПредставлениеПеременной(Элемент, Смещение, КэшСсылок));
		Иначе
			Строки.Добавить(Маркер + ПолучитьПредставлениеПеременной(Элемент.Значение, Смещение, КэшСсылок));
		КонецЕсли;
		
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Возврат СтрСоединить(Строки, Символы.ПС);
	
КонецФункции

Функция ДополнитьСтроку(Знач Результат, СимволовДополнить, Дополнение = " ", Слева = Истина)
	
	Стр = "";
	Для Сч = 1 По СимволовДополнить Цикл
		Стр = Стр + Дополнение;
	КонецЦикла;
	
	Возврат ?(Слева, Стр + Результат, Результат + Стр);
	
КонецФункции

Функция ЭтоСсылка(Значение)
	
	ЭтоСсылка = Ложь;
	
	ТипЗнч = ТипЗнч(Значение);
	ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч);
	
	Если ОбъектМетаданных <> Неопределено Тогда
		ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
		Массив = СтрРазделить(ПолноеИмя, ".");
		Массив[0] = Массив[0] + "Ссылка";
		ИмяТипа = СтрСоединить(Массив, ".");
		
		Попытка
			ЭтоСсылка = (ТипЗнч = Тип(ИмяТипа));
		Исключение
			ЭтоСсылка = Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Возврат ЭтоСсылка;
	
КонецФункции

// Раскрывает переменную для показа дочерних элементов в табло.
// 
// Параметры:
//   ХранилищеПеременных - Структура - хранилище переменных
//   КэшСсылок - Соответствие - кэш ссылок  
//   ПутьКДанным - Строка - путь вида "var_xxx.Свойство" или "var_xxx[0]"
//   ИмяПеременной - Строка - имя переменной для отображения
//
// Возвращаемое значение:
//   Структура, Неопределено - описание переменной с children или Неопределено
//
Функция РаскрытьПеременнуюВТаблоСервер(ХранилищеПеременных, КэшСсылок, ПутьКДанным, ИмяПеременной) Экспорт
	
	// Находим значение по пути через Вычислить
	Значение = Неопределено;
	
	Путь = СтрЗаменить(ПутьКДанным, "&quote;", """");
	
	Попытка
		Значение = Вычислить("ХранилищеПеременных." + Путь);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Если Значение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Восстанавливаем путь с экранированием кавычек
	Путь = СтрЗаменить(Путь, """", "&quote;");
	
	// Формируем описание переменной в зависимости от типа
	ТипЗнч = ТипЗнч(Значение);
	
	Если ТипЗнч = Тип("Структура") Тогда
		Возврат ПолучитьОписаниеСтруктурыПолное(Значение, ИмяПеременной, Путь, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("Соответствие") Тогда
		Возврат ПолучитьОписаниеСоответствияПолное(Значение, ИмяПеременной, Путь, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("Массив") Тогда
		Возврат ПолучитьОписаниеМассиваПолное(Значение, ИмяПеременной, Путь, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("СписокЗначений") Тогда
		Возврат ПолучитьОписаниеСпискаЗначенийПолное(Значение, ИмяПеременной, Путь, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("ТаблицаЗначений") Тогда
		Возврат ПолучитьОписаниеТаблицыЗначенийПолное(Значение, ИмяПеременной, Путь, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("СтрокаТаблицыЗначений") Тогда
		Возврат ПолучитьОписаниеСтрокиТаблицыПолное(Значение, ИмяПеременной, Путь, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("ДеревоЗначений") Тогда
		Возврат ПолучитьОписаниеДереваЗначенийПолное(Значение, ИмяПеременной, Путь, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("СтрокаДереваЗначений") Тогда
		Возврат ПолучитьОписаниеСтрокиДереваПолное(Значение, ИмяПеременной, Путь, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("КоллекцияСтрокДереваЗначений") Тогда
		Возврат ПолучитьОписаниеКоллекцииСтрокДереваПолное(Значение, ИмяПеременной, Путь, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("КлючИЗначение") Тогда
		Возврат ПолучитьОписаниеКлючаИЗначенияПолное(Значение, ИмяПеременной, Путь, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("ЭлементСпискаЗначений") Тогда
		Возврат ПолучитьОписаниеЭлементаСпискаПолное(Значение, ИмяПеременной, Путь, КэшСсылок);
	ИначеЕсли ТипЗнч = Тип("Запрос") Тогда
		Возврат ПолучитьОписаниеЗапросаПолное(Значение, ИмяПеременной, Путь, КэшСсылок);
	ИначеЕсли ЭтоСсылка(Значение) Тогда
		Возврат ПолучитьОписаниеСсылкиПолное(Значение, ИмяПеременной, Путь, КэшСсылок);
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Получает полное описание структуры для табло (с children).
Функция ПолучитьОписаниеСтруктурыПолное(Структура, ИмяПеременной, ПутьКДанным, КэшСсылок)
	
	Переменная = ПолучитьКраткуюСтруктуруПеременной(Структура, ИмяПеременной, ПутьКДанным, КэшСсылок);
	Переменная.Вставить("children", ПолучитьОписаниеСтруктуры(Структура, ПутьКДанным, КэшСсылок));
	
	Возврат Переменная;
	
КонецФункции

// Получает полное описание соответствия для табло (с children).
Функция ПолучитьОписаниеСоответствияПолное(Соответствие, ИмяПеременной, ПутьКДанным, КэшСсылок)
	
	Переменная = ПолучитьКраткуюСтруктуруПеременной(Соответствие, ИмяПеременной, ПутьКДанным, КэшСсылок);
	Переменная.Вставить("children", ПолучитьОписаниеСоответствия(Соответствие, ПутьКДанным, КэшСсылок));
	
	Возврат Переменная;
	
КонецФункции

// Получает полное описание массива для табло (с children).
Функция ПолучитьОписаниеМассиваПолное(Массив, ИмяПеременной, ПутьКДанным, КэшСсылок)
	
	Переменная = ПолучитьКраткуюСтруктуруПеременной(Массив, ИмяПеременной, ПутьКДанным, КэшСсылок);
	Переменная.Вставить("children", ПолучитьОписаниеМассива(Массив, ПутьКДанным, КэшСсылок));
	
	Возврат Переменная;
	
КонецФункции

// Получает полное описание списка значений для табло (с children).
Функция ПолучитьОписаниеСпискаЗначенийПолное(Список, ИмяПеременной, ПутьКДанным, КэшСсылок)
	
	Переменная = ПолучитьКраткуюСтруктуруПеременной(Список, ИмяПеременной, ПутьКДанным, КэшСсылок);
	Переменная.Вставить("children", ПолучитьОписаниеСпискаЗначений(Список, ПутьКДанным, КэшСсылок));
	
	Возврат Переменная;
	
КонецФункции

// Получает полное описание таблицы значений для табло (с children).
Функция ПолучитьОписаниеТаблицыЗначенийПолное(Таблица, ИмяПеременной, ПутьКДанным, КэшСсылок)
	
	Переменная = ПолучитьКраткуюСтруктуруПеременной(Таблица, ИмяПеременной, ПутьКДанным, КэшСсылок);
	Переменная.Вставить("children", ПолучитьОписаниеТаблицыЗначений(Таблица, ПутьКДанным, КэшСсылок));
	
	Возврат Переменная;
	
КонецФункции

// Получает полное описание строки таблицы значений для табло (с children).
Функция ПолучитьОписаниеСтрокиТаблицыПолное(СтрокаТаблицы, ИмяПеременной, ПутьКДанным, КэшСсылок)
	
	Переменная = ПолучитьКраткуюСтруктуруПеременной(СтрокаТаблицы, ИмяПеременной, ПутьКДанным, КэшСсылок);
	Переменная.Вставить("children", ПолучитьОписаниеСтрокиТаблицы(СтрокаТаблицы, ПутьКДанным, КэшСсылок));
	
	Возврат Переменная;
	
КонецФункции

// Получает полное описание дерева значений для табло (с children).
Функция ПолучитьОписаниеДереваЗначенийПолное(Дерево, ИмяПеременной, ПутьКДанным, КэшСсылок)
	
	Переменная = ПолучитьКраткуюСтруктуруПеременной(Дерево, ИмяПеременной, ПутьКДанным, КэшСсылок);
	Переменная.Вставить("children", ПолучитьОписаниеДереваЗначений(Дерево, ПутьКДанным, КэшСсылок));
	
	Возврат Переменная;
	
КонецФункции

// Получает полное описание строки дерева для табло (с children).
Функция ПолучитьОписаниеСтрокиДереваПолное(СтрокаДерева, ИмяПеременной, ПутьКДанным, КэшСсылок)
	
	Переменная = ПолучитьКраткуюСтруктуруПеременной(СтрокаДерева, ИмяПеременной, ПутьКДанным, КэшСсылок);
	Переменная.Вставить("children", ПолучитьОписаниеСтрокиДерева(СтрокаДерева, ПутьКДанным, КэшСсылок));
	
	Возврат Переменная;
	
КонецФункции

// Получает полное описание коллекции строк дерева для табло (с children).
Функция ПолучитьОписаниеКоллекцииСтрокДереваПолное(Коллекция, ИмяПеременной, ПутьКДанным, КэшСсылок)
	
	Переменная = ПолучитьКраткуюСтруктуруПеременной(Коллекция, ИмяПеременной, ПутьКДанным, КэшСсылок);
	Переменная.Вставить("children", ПолучитьОписаниеКоллекцииСтрокДерева(Коллекция, ПутьКДанным, КэшСсылок));
	
	Возврат Переменная;
	
КонецФункции

// Получает полное описание КлючИЗначение для табло (с children).
Функция ПолучитьОписаниеКлючаИЗначенияПолное(КлючЗначение, ИмяПеременной, ПутьКДанным, КэшСсылок)
	
	Переменная = ПолучитьКраткуюСтруктуруПеременной(КлючЗначение, ИмяПеременной, ПутьКДанным, КэшСсылок);
	Переменная.Вставить("children", ПолучитьОписаниеКлючаИЗначения(КлючЗначение, ПутьКДанным, КэшСсылок));
	
	Возврат Переменная;
	
КонецФункции

// Получает полное описание элемента списка для табло (с children).
Функция ПолучитьОписаниеЭлементаСпискаПолное(Элемент, ИмяПеременной, ПутьКДанным, КэшСсылок)
	
	Переменная = ПолучитьКраткуюСтруктуруПеременной(Элемент, ИмяПеременной, ПутьКДанным, КэшСсылок);
	Переменная.Вставить("children", ПолучитьОписаниеЭлементаСписка(Элемент, ПутьКДанным, КэшСсылок));
	
	Возврат Переменная;
	
КонецФункции

// Получает полное описание Запроса для табло (с children).
Функция ПолучитьОписаниеЗапросаПолное(Запрос, ИмяПеременной, ПутьКДанным, КэшСсылок)
	
	Переменная = ПолучитьКраткуюСтруктуруПеременной(Запрос, ИмяПеременной, ПутьКДанным, КэшСсылок);
	Переменная.Вставить("children", ПолучитьОписаниеЗапроса(Запрос, ПутьКДанным, КэшСсылок));
	
	Возврат Переменная;
	
КонецФункции

// Получает полное описание ссылки для табло (с children).
Функция ПолучитьОписаниеСсылкиПолное(Ссылка, ИмяПеременной, ПутьКДанным, КэшСсылок)
	
	Переменная = ПолучитьКраткуюСтруктуруПеременной(Ссылка, ИмяПеременной, ПутьКДанным, КэшСсылок);
	Переменная.Вставить("children", ПолучитьОписаниеСсылки(Ссылка, ПутьКДанным, КэшСсылок));
	
	Возврат Переменная;
	
КонецФункции

// Получает описание структуры для табло.
Функция ПолучитьОписаниеСтруктуры(Структура, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	Для Каждого КлючЗначение Из Структура Цикл
		ПутьЭлемента = ПутьКДанным + "." + КлючЗначение.Ключ;
		Переменная = ПолучитьКраткуюСтруктуруПеременной(КлючЗначение.Значение, КлючЗначение.Ключ, ПутьЭлемента, КэшСсылок);
		ИдентификаторПеременной = НовыйИдентификаторПеременной();
		Дочерние.Вставить(ИдентификаторПеременной, Переменная);
	КонецЦикла;
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание соответствия для табло.
Функция ПолучитьОписаниеСоответствия(Соответствие, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	Для Каждого КлючЗначение Из Соответствие Цикл
		КлючСтрока = СтрЗаменить(Строка(КлючЗначение.Ключ), """", "&quote;");
		ПутьЭлемента = ПутьКДанным + "[&quote;" + КлючСтрока + "&quote;]";
		Переменная = ПолучитьКраткуюСтруктуруПеременной(КлючЗначение.Значение, КлючСтрока, ПутьЭлемента, КэшСсылок);
		ИдентификаторПеременной = НовыйИдентификаторПеременной();
		Дочерние.Вставить(ИдентификаторПеременной, Переменная);
	КонецЦикла;
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание массива для табло.
Функция ПолучитьОписаниеМассива(Массив, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	Индекс = 0;
	
	Для Каждого Элемент Из Массив Цикл
		Имя = Формат(Индекс, "ЧН=; ЧГ=0");
		ПутьЭлемента = ПутьКДанным + "[" + Имя + "]";
		Переменная = ПолучитьКраткуюСтруктуруПеременной(Элемент, Имя, ПутьЭлемента, КэшСсылок);
		ИдентификаторПеременной = НовыйИдентификаторПеременной();
		Дочерние.Вставить(ИдентификаторПеременной, Переменная);
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание списка значений для табло.
Функция ПолучитьОписаниеСпискаЗначений(Список, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	Индекс = 0;
	
	Для Каждого Элемент Из Список Цикл
		Имя = Формат(Индекс, "ЧН=; ЧГ=0");
		ПутьЭлемента = ПутьКДанным + "[" + Имя + "]";
		Переменная = ПолучитьКраткуюСтруктуруПеременной(Элемент, Имя, ПутьЭлемента, КэшСсылок);
		ИдентификаторПеременной = НовыйИдентификаторПеременной();
		Дочерние.Вставить(ИдентификаторПеременной, Переменная);
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание элемента списка значений для табло.
Функция ПолучитьОписаниеЭлементаСписка(Элемент, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	// Значение
	ПутьЗначения = ПутьКДанным + ".Значение";
	ПеременнаяЗначение = ПолучитьКраткуюСтруктуруПеременной(Элемент.Значение, "Значение", ПутьЗначения, КэшСсылок);
	Дочерние.Вставить(НовыйИдентификаторПеременной(), ПеременнаяЗначение);
	
	// Представление
	ПутьПредставления = ПутьКДанным + ".Представление";
	ПеременнаяПредставление = ПолучитьКраткуюСтруктуруПеременной(Элемент.Представление, "Представление", ПутьПредставления, КэшСсылок);
	Дочерние.Вставить(НовыйИдентификаторПеременной(), ПеременнаяПредставление);
	
	// Пометка
	ПутьПометки = ПутьКДанным + ".Пометка";
	ПеременнаяПометка = ПолучитьКраткуюСтруктуруПеременной(Элемент.Пометка, "Пометка", ПутьПометки, КэшСсылок);
	Дочерние.Вставить(НовыйИдентификаторПеременной(), ПеременнаяПометка);
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание таблицы значений для табло.
Функция ПолучитьОписаниеТаблицыЗначений(Таблица, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	Индекс = 0;
	
	Для Каждого Строка Из Таблица Цикл
		Имя = Формат(Индекс, "ЧН=; ЧГ=0");
		ПутьСтроки = ПутьКДанным + "[" + Имя + "]";
		Переменная = ПолучитьКраткуюСтруктуруПеременной(Строка, Имя, ПутьСтроки, КэшСсылок);
		ИдентификаторПеременной = НовыйИдентификаторПеременной();
		Дочерние.Вставить(ИдентификаторПеременной, Переменная);
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание строки таблицы значений для табло.
Функция ПолучитьОписаниеСтрокиТаблицы(СтрокаТаблицы, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	Владелец = СтрокаТаблицы.Владелец();
	
	Для Каждого Колонка Из Владелец.Колонки Цикл
		ИмяКолонки = Колонка.Имя;
		ПутьКолонки = ПутьКДанным + "." + ИмяКолонки;
		Значение = СтрокаТаблицы[ИмяКолонки];
		Переменная = ПолучитьКраткуюСтруктуруПеременной(Значение, ИмяКолонки, ПутьКолонки, КэшСсылок);
		ИдентификаторПеременной = НовыйИдентификаторПеременной();
		Дочерние.Вставить(ИдентификаторПеременной, Переменная);
	КонецЦикла;
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание дерева значений для табло.
Функция ПолучитьОписаниеДереваЗначений(Дерево, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	// Добавляем ветку "Строки"
	ПутьСтрок = ПутьКДанным + ".Строки";
	Переменная = ПолучитьКраткуюСтруктуруПеременной(Дерево.Строки, "Строки", ПутьСтрок, КэшСсылок);
	Дочерние.Вставить(НовыйИдентификаторПеременной(), Переменная);
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание коллекции строк дерева значений для табло.
Функция ПолучитьОписаниеКоллекцииСтрокДерева(Коллекция, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	Индекс = 0;
	
	Для Каждого Строка Из Коллекция Цикл
		Имя = Формат(Индекс, "ЧН=; ЧГ=0");
		ПутьСтроки = ПутьКДанным + "[" + Имя + "]";
		Переменная = ПолучитьКраткуюСтруктуруПеременной(Строка, Имя, ПутьСтроки, КэшСсылок);
		ИдентификаторПеременной = НовыйИдентификаторПеременной();
		Дочерние.Вставить(ИдентификаторПеременной, Переменная);
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание строки дерева значений для табло.
Функция ПолучитьОписаниеСтрокиДерева(СтрокаДерева, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	Владелец = СтрокаДерева.Владелец();
	
	// Добавляем колонки
	Если ТипЗнч(Владелец) = Тип("ДеревоЗначений") Тогда
		Колонки = Владелец.Колонки;
	Иначе
		Колонки = Владелец.Владелец().Колонки;
	КонецЕсли;
	
	Для Каждого Колонка Из Колонки Цикл
		ИмяКолонки = Колонка.Имя;
		ПутьКолонки = ПутьКДанным + "." + ИмяКолонки;
		Значение = СтрокаДерева[ИмяКолонки];
		Переменная = ПолучитьКраткуюСтруктуруПеременной(Значение, ИмяКолонки, ПутьКолонки, КэшСсылок);
		ИдентификаторПеременной = НовыйИдентификаторПеременной();
		Дочерние.Вставить(ИдентификаторПеременной, Переменная);
	КонецЦикла;
	
	// Добавляем вложенные строки
	Если СтрокаДерева.Строки.Количество() > 0 Тогда
		ПутьСтрок = ПутьКДанным + ".Строки";
		Переменная = ПолучитьКраткуюСтруктуруПеременной(СтрокаДерева.Строки, "Строки", ПутьСтрок, КэшСсылок);
		Дочерние.Вставить(НовыйИдентификаторПеременной(), Переменная);
	КонецЕсли;
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание КлючИЗначение для табло.
Функция ПолучитьОписаниеКлючаИЗначения(КлючЗначение, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	// Ключ
	ПутьКлюча = ПутьКДанным + ".Ключ";
	ПеременнаяКлюч = ПолучитьКраткуюСтруктуруПеременной(КлючЗначение.Ключ, "Ключ", ПутьКлюча, КэшСсылок);
	Дочерние.Вставить(НовыйИдентификаторПеременной(), ПеременнаяКлюч);
	
	// Значение  
	ПутьЗначения = ПутьКДанным + ".Значение";
	ПеременнаяЗначение = ПолучитьКраткуюСтруктуруПеременной(КлючЗначение.Значение, "Значение", ПутьЗначения, КэшСсылок);
	Дочерние.Вставить(НовыйИдентификаторПеременной(), ПеременнаяЗначение);
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание Запроса для табло.
Функция ПолучитьОписаниеЗапроса(Запрос, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	// Текст запроса
	ПутьТекста = ПутьКДанным + ".Текст";
	ПеременнаяТекст = ПолучитьКраткуюСтруктуруПеременной(Запрос.Текст, "Текст", ПутьТекста, КэшСсылок);
	Дочерние.Вставить(НовыйИдентификаторПеременной(), ПеременнаяТекст);
	
	// Параметры
	ПутьПараметров = ПутьКДанным + ".Параметры";
	ПеременнаяПараметры = ПолучитьКраткуюСтруктуруПеременной(Запрос.Параметры, "Параметры", ПутьПараметров, КэшСсылок);
	Дочерние.Вставить(НовыйИдентификаторПеременной(), ПеременнаяПараметры);
	
	Возврат Дочерние;
	
КонецФункции

// Получает описание ссылки для табло.
Функция ПолучитьОписаниеСсылки(Ссылка, ПутьКДанным, КэшСсылок)
	
	Дочерние = Новый Структура;
	
	Попытка
		
		ОбъектМетаданных = Ссылка.Метаданные();
		
		// Реквизиты
		Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
			ИмяРеквизита = Реквизит.Имя;
			ПутьРеквизита = ПутьКДанным + "." + ИмяРеквизита;
			Попытка
				Значение = Ссылка[ИмяРеквизита];
			Исключение
				Продолжить;
			КонецПопытки;
			Переменная = ПолучитьКраткуюСтруктуруПеременной(Значение, ИмяРеквизита, ПутьРеквизита, КэшСсылок);
			ИдентификаторПеременной = НовыйИдентификаторПеременной();
			Дочерние.Вставить(ИдентификаторПеременной, Переменная);
		КонецЦикла;
		
		// Табличные части
		Для Каждого ТабличнаяЧасть Из ОбъектМетаданных.ТабличныеЧасти Цикл
			ИмяТЧ = ТабличнаяЧасть.Имя;
			ПутьТЧ = ПутьКДанным + "." + ИмяТЧ;
			Попытка
				Значение = Ссылка[ИмяТЧ];
			Исключение
				Продолжить;
			КонецПопытки;
			Переменная = ПолучитьКраткуюСтруктуруПеременной(Значение, ИмяТЧ, ПутьТЧ, КэшСсылок);
			ИдентификаторПеременной = НовыйИдентификаторПеременной();
			Дочерние.Вставить(ИдентификаторПеременной, Переменная);
		КонецЦикла;
		
	Исключение
		// Не удалось получить метаданные
	КонецПопытки;
	
	Возврат Дочерние;
	
КонецФункции

#КонецОбласти

#Область ПользовательскиеОбъектыИМетоды

// Добавляет переменную в контекст редактора.
// Переменная будет доступна в автодополнении.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - форма с редактором
//   ИмяПеременной - Строка - имя переменной (например, "_Заказ", "_Данные")
//   ТипИлиЗначение - ОписаниеТипов, Тип, Строка, Произвольный - тип переменной:
//                   * ОписаниеТипов - используется первый подходящий тип
//                   * Тип - тип напрямую
//                   * Строка - полное имя типа ("Справочник.Номенклатура")
//                   * Произвольный - тип определится по значению
//
// Пример:
//   // Вариант 1: По описанию типов
//   конс_ПодключаемаяКонсольСервер.ДобавитьПеременную(Форма, "_Товар", 
//       Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
//   
//   // Вариант 2: По типу
//   конс_ПодключаемаяКонсольСервер.ДобавитьПеременную(Форма, "_Данные", 
//       Тип("Структура"));
//
//   // Вариант 3: По имени типа (строка)
//   конс_ПодключаемаяКонсольСервер.ДобавитьПеременную(Форма, "_Клиент", 
//       "Справочник.Контрагенты");
//   
//   // Вариант 4: По значению - тип определится автоматически
//   конс_ПодключаемаяКонсольСервер.ДобавитьПеременную(Форма, "_Клиент", СсылкаНаКонтрагента);
//
//   // Вариант 5: Без типа - просто переменная без свойств
//   конс_ПодключаемаяКонсольСервер.ДобавитьПеременную(Форма, "_Результат");
//
Процедура ДобавитьПеременную(Форма, ИмяПеременной, ТипИлиЗначение = Неопределено) Экспорт
	
	// Получаем текущие переменные из JSON
	Переменные = ПрочитатьJSONПеременных(Форма);
	
	// Определяем ссылку на тип
	СсылкаНаТип = ОпределитьСсылкуНаТип(ТипИлиЗначение);
	
	// Создаём описание переменной
	Переменная = Новый Структура("properties", Новый Структура);
	
	Если ЗначениеЗаполнено(СсылкаНаТип) Тогда
		Переменная.Вставить("ref", СсылкаНаТип);
	КонецЕсли;
	
	Переменные.Вставить(ИмяПеременной, Переменная);
	
	// Сохраняем обратно в JSON
	СохранитьJSONПеременных(Форма, Переменные);
	
КонецПроцедуры

// Добавляет функцию в контекст редактора.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - форма с редактором
//   ИмяФункции - Строка - имя функции
//   Описание - Строка - описание функции
//   Параметры - Массив, Неопределено - массив параметров (см. НовыйПараметрФункции)
//   ТипВозврата - Строка - тип возвращаемого значения
//
// Пример:
//   // Функция без параметров:
//   конс_ПодключаемаяКонсольСервер.ДобавитьФункциюВКонтекст(Форма, 
//       "ПолучитьТекущегоПользователя", 
//       "Возвращает текущего пользователя");
//
//   // Функция с параметрами:
//   Параметры = Новый Массив;
//   Параметры.Добавить(конс_ПодключаемаяКонсольСервер.НовыйПараметрФункции("Сумма", "Число", "Сумма заказа"));
//   Параметры.Добавить(конс_ПодключаемаяКонсольСервер.НовыйПараметрФункции("ПроцентСкидки", "Число", "Процент скидки"));
//   конс_ПодключаемаяКонсольСервер.ДобавитьФункциюВКонтекст(Форма,
//       "ВычислитьСкидку",
//       "Вычисляет скидку для клиента",
//       Параметры,
//       "Число");
//
Процедура ДобавитьФункциюВКонтекст(Форма, ИмяФункции, Описание = "", Параметры = Неопределено, ТипВозврата = "") Экспорт
	
	// Получаем текущие функции из JSON
	Функции = ПрочитатьJSONФункций(Форма);
	
	// Создаём описание функции в формате редактора
	Функция_ = Новый Структура;
	Функция_.Вставить("name", ИмяФункции);
	
	Если ЗначениеЗаполнено(Описание) Тогда
		Функция_.Вставить("description", Описание);
	КонецЕсли;
	
	// Формируем сигнатуру из параметров
	СтрокаПараметров = "(";
	ОписанияПараметров = Новый Структура;
	
	Если Параметры <> Неопределено И Параметры.Количество() > 0 Тогда
		ЧастиПараметров = Новый Массив;
		Для Каждого Параметр Из Параметры Цикл
			ИмяПараметра = Параметр.Имя;
			ТипПараметра = Параметр.Тип;
			ОписаниеПараметра = "";
			Обязательный = Истина;
			
			Если Параметр.Свойство("Описание") Тогда
				ОписаниеПараметра = Параметр.Описание;
			КонецЕсли;
			
			Если Параметр.Свойство("Обязательный") Тогда
				Обязательный = Параметр.Обязательный;
			КонецЕсли;
			
			// Формируем часть сигнатуры: "Имя: Тип" или "Имя?: Тип"
			Если Обязательный Тогда
				ЧастиПараметров.Добавить(ИмяПараметра + ": " + ТипПараметра);
			Иначе
				ЧастиПараметров.Добавить(ИмяПараметра + "?: " + ТипПараметра);
			КонецЕсли;
			
			// Добавляем описание параметра
			Если ЗначениеЗаполнено(ОписаниеПараметра) Тогда
				ОписанияПараметров.Вставить(ИмяПараметра, ОписаниеПараметра);
			КонецЕсли;
		КонецЦикла;
		
		СтрокаПараметров = СтрокаПараметров + СтрСоединить(ЧастиПараметров, ", ");
	КонецЕсли;
	
	СтрокаПараметров = СтрокаПараметров + ")";
	
	// Добавляем тип возврата
	Если ЗначениеЗаполнено(ТипВозврата) Тогда
		СтрокаПараметров = СтрокаПараметров + ": " + ТипВозврата;
	КонецЕсли;
	
	// Формируем сигнатуру
	СигнатураПоУмолчанию = Новый Структура;
	СигнатураПоУмолчанию.Вставить("СтрокаПараметров", СтрокаПараметров);
	СигнатураПоУмолчанию.Вставить("Параметры", ОписанияПараметров);
	Функция_.Вставить("signature", Новый Структура("default", СигнатураПоУмолчанию));
	
	Функции.Вставить(ИмяФункции, Функция_);
	
	// Сохраняем обратно в JSON
	СохранитьJSONФункций(Форма, Функции);
	
КонецПроцедуры

// Создаёт описание параметра функции для ДобавитьФункциюВКонтекст.
// 
// Параметры:
//   Имя - Строка - имя параметра
//   Тип - Строка - тип параметра (Число, Строка, Булево, СправочникСсылка и т.д.)
//   Описание - Строка - описание параметра
//   Обязательный - Булево - является ли параметр обязательным (по умолчанию Истина)
//
// Возвращаемое значение:
//   Структура - описание параметра
//
// Пример:
//   Параметры = Новый Массив;
//   Параметры.Добавить(конс_ПодключаемаяКонсольСервер.НовыйПараметрФункции("Сумма", "Число", "Сумма заказа"));
//   Параметры.Добавить(конс_ПодключаемаяКонсольСервер.НовыйПараметрФункции("Скидка", "Число", "Процент", Ложь));
//
Функция НовыйПараметрФункции(Имя, Тип, Описание = "", Обязательный = Истина) Экспорт
	
	Возврат Новый Структура("Имя, Тип, Описание, Обязательный", Имя, Тип, Описание, Обязательный);
	
КонецФункции

// Получает JSON пользовательских переменных для загрузки в редактор.
// Вызывается автоматически при инициализации, но можно вызвать вручную.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//
// Возвращаемое значение:
//   Строка - JSON для передачи в updateMetadata
//
Функция ПолучитьJSONПеременных(Форма) Экспорт
	
	Если ЕстьРеквизит(Форма, "конс_JSONПеременных") И ЗначениеЗаполнено(Форма.конс_JSONПеременных) Тогда
		// Оборачиваем в customObjects если ещё не обёрнуто
		Данные = Форма.конс_JSONПеременных;
		Если СтрНайти(Данные, "customObjects") = 0 Тогда
			Возврат "{""customObjects"":" + Данные + "}";
		КонецЕсли;
		Возврат Данные;
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Получает JSON пользовательских функций для загрузки в редактор.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//
// Возвращаемое значение:
//   Строка - JSON для передачи в updateCustomFunctions
//
Функция ПолучитьJSONФункций(Форма) Экспорт
	
	Если ЕстьРеквизит(Форма, "конс_JSONФункций") И ЗначениеЗаполнено(Форма.конс_JSONФункций) Тогда
		Данные = Форма.конс_JSONФункций;
		Если СтрНайти(Данные, "customFunctions") = 0 Тогда
			Возврат "{""customFunctions"":" + Данные + "}";
		КонецЕсли;
		Возврат Данные;
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Читает переменные из JSON реквизита формы.
Функция ПрочитатьJSONПеременных(Форма)
	
	Если Не ЕстьРеквизит(Форма, "конс_JSONПеременных") Тогда
		// Реквизит ещё не создан - нужно сначала вызвать ИнициализироватьРедактор
		Возврат Новый Структура;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Форма.конс_JSONПеременных) Тогда
		Попытка
			Чтение = Новый ЧтениеJSON;
			Чтение.УстановитьСтроку(Форма.конс_JSONПеременных);
			Возврат ПрочитатьJSON(Чтение);
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	Возврат Новый Структура;
	
КонецФункции

// Сохраняет переменные в JSON реквизит формы.
Процедура СохранитьJSONПеременных(Форма, Переменные)
	
	Если Не ЕстьРеквизит(Форма, "конс_JSONПеременных") Тогда
		ВызватьИсключение "Реквизит конс_JSONПеременных не найден. Сначала вызовите ИнициализироватьРедактор.";
	КонецЕсли;
	
	Файл = Новый ЗаписьJSON;
	Файл.УстановитьСтроку();
	ЗаписатьJSON(Файл, Переменные);
	Форма.конс_JSONПеременных = Файл.Закрыть();
	
КонецПроцедуры

// Читает функции из JSON реквизита формы.
Функция ПрочитатьJSONФункций(Форма)
	
	Если Не ЕстьРеквизит(Форма, "конс_JSONФункций") Тогда
		// Реквизит ещё не создан - нужно сначала вызвать ИнициализироватьРедактор
		Возврат Новый Структура;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Форма.конс_JSONФункций) Тогда
		Попытка
			Чтение = Новый ЧтениеJSON;
			Чтение.УстановитьСтроку(Форма.конс_JSONФункций);
			Возврат ПрочитатьJSON(Чтение);
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	Возврат Новый Структура;
	
КонецФункции

// Сохраняет функции в JSON реквизит формы.
Процедура СохранитьJSONФункций(Форма, Функции)
	
	Если Не ЕстьРеквизит(Форма, "конс_JSONФункций") Тогда
		ВызватьИсключение "Реквизит конс_JSONФункций не найден. Сначала вызовите ИнициализироватьРедактор.";
	КонецЕсли;
	
	Файл = Новый ЗаписьJSON;
	Файл.УстановитьСтроку();
	ЗаписатьJSON(Файл, Функции);
	Форма.конс_JSONФункций = Файл.Закрыть();
	
КонецПроцедуры

// Универсальная функция определения ссылки на тип для редактора.
// 
// Параметры:
//   ТипИлиЗначение - ОписаниеТипов, Тип, Строка, Произвольный
//
// Возвращаемое значение:
//   Строка - ссылка на тип для редактора или пустая строка
//
Функция ОпределитьСсылкуНаТип(ТипИлиЗначение)
	
	Если ТипИлиЗначение = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	ТипПараметра = ТипЗнч(ТипИлиЗначение);
	
	// Вариант 1: ОписаниеТипов
	Если ТипПараметра = Тип("ОписаниеТипов") Тогда
		Возврат ОпределитьСсылкуПоОписаниюТипов(ТипИлиЗначение);
	КонецЕсли;
	
	// Вариант 2: Тип
	Если ТипПараметра = Тип("Тип") Тогда
		Возврат ОпределитьСсылкуПоТипу(ТипИлиЗначение);
	КонецЕсли;
	
	// Вариант 3: Строка (имя типа)
	Если ТипПараметра = Тип("Строка") И ЗначениеЗаполнено(ТипИлиЗначение) Тогда
		Возврат ПреобразоватьИмяТипаВСсылку(ТипИлиЗначение);
	КонецЕсли;
	
	// Вариант 4: Произвольное значение - определяем тип по значению
	Возврат ОпределитьСсылкуПоЗначению(ТипИлиЗначение);
	
КонецФункции

// Определяет ссылку на тип по ОписаниюТипов.
Функция ОпределитьСсылкуПоОписаниюТипов(ОписаниеТипов)
	
	МассивТипов = ОписаниеТипов.Типы();
	
	Для Каждого ТекущийТип Из МассивТипов Цикл
		Ссылка = ОпределитьСсылкуПоТипу(ТекущийТип);
		Если ЗначениеЗаполнено(Ссылка) Тогда
			Возврат Ссылка;
		КонецЕсли;
	КонецЦикла;
	
	// Проверяем общие типы
	Если МассивТипов.Количество() = 1 Тогда
		ИмяТипа = Строка(МассивТипов[0]);
		Возврат СоответствиеОбщихТипов().Получить(ИмяТипа);
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Определяет ссылку на тип по объекту Тип.
Функция ОпределитьСсылкуПоТипу(Тип_)
	
	// Сначала проверяем общие типы
	ИмяТипа = Строка(Тип_);
	СсылкаОбщегоТипа = СоответствиеОбщихТипов().Получить(ИмяТипа);
	Если ЗначениеЗаполнено(СсылкаОбщегоТипа) Тогда
		Возврат СсылкаОбщегоТипа;
	КонецЕсли;
	
	// Пробуем получить метаданные для ссылочных типов
	Попытка
		ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип_);
		
		Если ОбъектМетаданных <> Неопределено Тогда
			ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
			Возврат ПреобразоватьИмяТипаВСсылку(ПолноеИмя);
		КонецЕсли;
	Исключение
		// Не ссылочный тип
	КонецПопытки;
	
	Возврат "";
	
КонецФункции

// Возвращает соответствие общих типов 1С на типы редактора.
// Формат ссылок: classes.ИмяКласса (на русском языке)
// ВАЖНО: Строка(Тип("ТаблицаЗначений")) может возвращать как "ТаблицаЗначений", 
// так и "Таблица значений" (с пробелом) в зависимости от версии платформы.
Функция СоответствиеОбщихТипов()
	
	Соответствие = Новый Соответствие;
	
	// Коллекции - имеют методы в редакторе
	// Добавляем варианты с пробелами и без
	Соответствие.Вставить("Структура", "classes.Структура");
	Соответствие.Вставить("ФиксированнаяСтруктура", "classes.ФиксированнаяСтруктура");
	Соответствие.Вставить("Фиксированная структура", "classes.ФиксированнаяСтруктура");
	Соответствие.Вставить("Соответствие", "classes.Соответствие");
	Соответствие.Вставить("ФиксированноеСоответствие", "classes.ФиксированноеСоответствие");
	Соответствие.Вставить("Фиксированное соответствие", "classes.ФиксированноеСоответствие");
	Соответствие.Вставить("Массив", "classes.Массив");
	Соответствие.Вставить("ФиксированныйМассив", "classes.ФиксированныйМассив");
	Соответствие.Вставить("Фиксированный массив", "classes.ФиксированныйМассив");
	Соответствие.Вставить("СписокЗначений", "classes.СписокЗначений");
	Соответствие.Вставить("Список значений", "classes.СписокЗначений");
	Соответствие.Вставить("ТаблицаЗначений", "classes.ТаблицаЗначений");
	Соответствие.Вставить("Таблица значений", "classes.ТаблицаЗначений");
	Соответствие.Вставить("ДеревоЗначений", "classes.ДеревоЗначений");
	Соответствие.Вставить("Дерево значений", "classes.ДеревоЗначений");
	Соответствие.Вставить("КоллекцияКолонокТаблицыЗначений", "classes.КоллекцияКолонокТаблицыЗначений");
	Соответствие.Вставить("Коллекция колонок таблицы значений", "classes.КоллекцияКолонокТаблицыЗначений");
	Соответствие.Вставить("КоллекцияКолонокДереваЗначений", "classes.КоллекцияКолонокДереваЗначений");
	Соответствие.Вставить("Коллекция колонок дерева значений", "classes.КоллекцияКолонокДереваЗначений");
	
	// Работа с данными
	Соответствие.Вставить("Запрос", "classes.Запрос");
	Соответствие.Вставить("РезультатЗапроса", "classes.РезультатЗапроса");
	Соответствие.Вставить("Результат запроса", "classes.РезультатЗапроса");
	Соответствие.Вставить("ВыборкаИзРезультатаЗапроса", "classes.ВыборкаИзРезультатаЗапроса");
	Соответствие.Вставить("Выборка из результата запроса", "classes.ВыборкаИзРезультатаЗапроса");
	Соответствие.Вставить("ДвоичныеДанные", "classes.ДвоичныеДанные");
	Соответствие.Вставить("Двоичные данные", "classes.ДвоичныеДанные");
	
	// HTTP
	Соответствие.Вставить("HTTPЗапрос", "classes.HTTPЗапрос");
	Соответствие.Вставить("HTTP запрос", "classes.HTTPЗапрос");
	Соответствие.Вставить("HTTPОтвет", "classes.HTTPОтвет");
	Соответствие.Вставить("HTTP ответ", "classes.HTTPОтвет");
	Соответствие.Вставить("HTTPСоединение", "classes.HTTPСоединение");
	Соответствие.Вставить("HTTP соединение", "classes.HTTPСоединение");
	
	// JSON/XML
	Соответствие.Вставить("ЗаписьJSON", "classes.ЗаписьJSON");
	Соответствие.Вставить("Запись JSON", "classes.ЗаписьJSON");
	Соответствие.Вставить("ЧтениеJSON", "classes.ЧтениеJSON");
	Соответствие.Вставить("Чтение JSON", "classes.ЧтениеJSON");
	Соответствие.Вставить("ЗаписьXML", "classes.ЗаписьXML");
	Соответствие.Вставить("Запись XML", "classes.ЗаписьXML");
	Соответствие.Вставить("ЧтениеXML", "classes.ЧтениеXML");
	Соответствие.Вставить("Чтение XML", "classes.ЧтениеXML");
	
	// Файлы и потоки
	Соответствие.Вставить("Файл", "classes.Файл");
	Соответствие.Вставить("ТекстовыйДокумент", "classes.ТекстовыйДокумент");
	Соответствие.Вставить("Текстовый документ", "classes.ТекстовыйДокумент");
	Соответствие.Вставить("ТабличныйДокумент", "classes.ТабличныйДокумент");
	Соответствие.Вставить("Табличный документ", "classes.ТабличныйДокумент");
	
	// Примитивы (без автодополнения свойств)
	Соответствие.Вставить("Строка", "");
	Соответствие.Вставить("Число", "");
	Соответствие.Вставить("Булево", "");
	Соответствие.Вставить("Дата", "");
	
	Возврат Соответствие;
	
КонецФункции

// Преобразует полное имя типа 1С в ссылку для редактора.
Функция ПреобразоватьИмяТипаВСсылку(ПолноеИмяТипа)
	
	Части = СтрРазделить(ПолноеИмяТипа, ".");
	
	Если Части.Количество() < 2 Тогда
		Возврат "";
	КонецЕсли;
	
	ТипКоллекции = НРег(Части[0]);
	ИмяОбъекта = Части[1];
	
	// Маппинг типов 1С на типы редактора
	Соответствие = Новый Соответствие;
	Соответствие.Вставить("справочник", "catalogs");
	Соответствие.Вставить("документ", "documents");
	Соответствие.Вставить("перечисление", "enums");
	Соответствие.Вставить("регистрсведений", "infoRegs");
	Соответствие.Вставить("регистрнакопления", "accumRegs");
	Соответствие.Вставить("обработка", "dataProc");
	Соответствие.Вставить("отчет", "reports");
	
	ТипРедактора = Соответствие.Получить(ТипКоллекции);
	
	Если ТипРедактора = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат ТипРедактора + "." + ИмяОбъекта;
	
КонецФункции

// Определяет ссылку на тип по значению.
Функция ОпределитьСсылкуПоЗначению(Значение)
	
	ТипЗначения = ТипЗнч(Значение);
	
	// Пробуем получить метаданные для ссылочных типов
	Попытка
		ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗначения);
		
		Если ОбъектМетаданных <> Неопределено Тогда
			ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
			Возврат ПреобразоватьИмяТипаВСсылку(ПолноеИмя);
		КонецЕсли;
	Исключение
		// Не ссылочный тип
	КонецПопытки;
	
	Возврат "";
	
КонецФункции

#Область Сниппеты

// Добавляет сниппет (шаблон кода) в контекст редактора.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - форма с редактором
//   Префикс - Строка - текст для вызова сниппета (например, "Если", "Для")
//   ТелоСниппета - Строка - код шаблона с плейсхолдерами ${1:название}
//   Описание - Строка - описание сниппета
//
// Примечание:
//   Плейсхолдеры: ${1:имя}, ${2:имя}, ${0:последний}
//   \n - перевод строки, \t - табуляция
//
// Пример:
//   // Простой сниппет
//   конс_ПодключаемаяКонсольСервер.ДобавитьСниппет(Форма, 
//       "Для", 
//       "Для ${1:Индекс} = ${2:0} По ${3:Количество} Цикл\n\t${0}\nКонецЦикла;",
//       "Цикл Для");
//
//   // Сниппет с вызовом функции
//   конс_ПодключаемаяКонсольСервер.ДобавитьСниппет(Форма,
//       "Запрос",
//       "Запрос = Новый Запрос;\nЗапрос.Текст = \"${1:SELECT}\";",
//       "Создание запроса");
//
Процедура ДобавитьСниппет(Форма, Префикс, ТелоСниппета, Описание = "") Экспорт
	
	// Получаем текущие сниппеты из JSON
	Сниппеты = ПрочитатьJSONСниппетов(Форма);
	
	// Создаём описание сниппета
	Сниппет = Новый Структура;
	Сниппет.Вставить("prefix", Префикс);
	Сниппет.Вставить("body", ТелоСниппета);
	
	Если ЗначениеЗаполнено(Описание) Тогда
		Сниппет.Вставить("description", Описание);
	КонецЕсли;
	
	Сниппеты.Вставить(Префикс, Сниппет);
	
	// Сохраняем обратно в JSON
	СохранитьJSONСниппетов(Форма, Сниппеты);
	
КонецПроцедуры

// Получает JSON сниппетов для загрузки в редактор.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения
//
// Возвращаемое значение:
//   Строка - JSON для передачи в updateSnippets
//
Функция ПолучитьJSONСниппетов(Форма) Экспорт
	
	Если ЕстьРеквизит(Форма, "конс_JSONСниппетов") И ЗначениеЗаполнено(Форма.конс_JSONСниппетов) Тогда
		Данные = Форма.конс_JSONСниппетов;
		Если СтрНайти(Данные, "snippets") = 0 Тогда
			Возврат "{""snippets"":" + Данные + "}";
		КонецЕсли;
		Возврат Данные;
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

// Читает сниппеты из JSON реквизита формы.
Функция ПрочитатьJSONСниппетов(Форма)
	
	Если Не ЕстьРеквизит(Форма, "конс_JSONСниппетов") Тогда
		Возврат Новый Структура;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Форма.конс_JSONСниппетов) Тогда
		Попытка
			Чтение = Новый ЧтениеJSON;
			Чтение.УстановитьСтроку(Форма.конс_JSONСниппетов);
			Возврат ПрочитатьJSON(Чтение);
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	Возврат Новый Структура;
	
КонецФункции

// Сохраняет сниппеты в JSON реквизит формы.
Процедура СохранитьJSONСниппетов(Форма, Сниппеты)
	
	Если Не ЕстьРеквизит(Форма, "конс_JSONСниппетов") Тогда
		ВызватьИсключение "Реквизит конс_JSONСниппетов не найден. Сначала вызовите ИнициализироватьРедактор.";
	КонецЕсли;
	
	Файл = Новый ЗаписьJSON;
	Файл.УстановитьСтроку();
	ЗаписатьJSON(Файл, Сниппеты);
	Форма.конс_JSONСниппетов = Файл.Закрыть();
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти
